%!TEX root = main.tex
\chapter{Introducci\'on}
\label{cap:introduccion}
En la actualidad, el software se encuentra en todos los aspectos de la vida diaria, y en general la expectativa del usuario es confiar en que el mismo simplemente funciona. Nadie espera que el auto no arranque por un error en el software embebido que utiliza, el cajero de un banco no retorne billetes al realizar una extracci\'on v\'alida, que el reloj del celular marque un horario incorrecto, etc. Sin embargo, para nombrar algunos ejemplos de que esto no sucede, en 2015, se descubri\'o un bug en el modelo Boing 787 Dreamliner que pod\'ia causar el apagado de todos los generadores el\'ectricos del avi\'on si \'este permanec\'ia encendido por m\'as de 248 d\'ias; En los 80, un error en el c\'odigo del controlador para la m\'aquina de terapia de radiaci\'on, \emph{Therac-25} caus\'o la muerte de varios pacientes al administrar cantidades excesivas de radiaci\'on beta; En 2018 un bug en WhatsApp causaba que la aplicaci\'on, y en muchos casos, el dispositivo, dejara de responder, si se recib\'ia un mensaje en Unicode conteniendo una secuencia que repet\'ia el caract\'er especial que especif\'ica la direcci\'on del texto.
%REF: BUG AVION: https://s3.amazonaws.com/public-inspection.federalregister.gov/2015-10066.pdf
%REF: THREAC-25, CITATION NEEDED?
%REF: BLACK DOT OF DEATH, CITATION NEEDED?
Claramente, asumir que el software simplemente funciona, no es posible. Los errores en un programa pueden tener consecuencias que van desde una molestia menor al usuario, hasta la perdida de vidas. Esto evidencia un problema a resolver, evaluar la correctitud de un programa, es decir, si para todo escenario de uso, el cual incluye entradas directas e indirectas, el programa da el resultado esperado. \'Esto es en general inviable salvo para programas triviales, por lo que solo un subconjunto de estos escenarios puede ser evaluado. Cuantos y cuales de todos los escenarios se seleccionan est\'a directamente relacionado con la confianza de que, en caso de no encontrar fallas, el software sea correcto.

No solamente es necesario un conjunto de escenarios, el comportamiento esperado requiere ser definido, y la forma m\'as simple es usando un valor esperado, por ejemplo, esperar que llamar a un m\'etodo \texttt{helloWorld()} retorne la cadena \emph{"Hello World"}; un ejemplo m\'as complejo es que luego de ejecutar el m\'etodo \texttt{insert(3)} sobre una lista vac\'ia, llamar al m\'etodo \texttt{contains(3)} retorne verdadero. Otra forma de evaluar el comportamiento esperado es evaluando propiedades como que para una lista simplemente encadenada, luego de ejecutar un m\'etodo particular, la misma est\'e ordenada. Lo que define el comportamiento esperado es lo que se conoce como \emph{Or\'aculo}.

Podemos entonces definir a un test como una serie de pasos conteniendo tres partes principales: \emph{Preparaci\'on}(Arrange), consiste en definir o construir el escenario sobre el que se va a evaluar un programa; \emph{Ejecuci\'on}(Act), donde se va a ejecutar el programa a evaluar; \emph{Evaluaci\'on}(Assert), donde se va a evaluar el resultado obtenido contra el esperado.

Un conjunto de tests debe entonces, ser finito, por que no es posible utilizar todos los escenarios posibles; su ejecuci\'on debe requerir recursos razonables, donde estos van a depender del contexto y los recursos disponibles, aunque en general es esperable que al menos haya un conjunto de tests que puedan ser ejecutados de manera r\'apida como apoyo al desarrollador; finalmente el \'exito en la execuci\'on de estos tests, es decir que ninguno detecte una diferencia entre el resultado obtenido y el esperado, deber\'ia servir como control de calidad del software.

Es necesario contar con un criterio para evaluar la calidad de un conjunto de tests. Dado que al ser finito, la confianza que genera en la correctitud de un programa va a depender de cuales tests fueron elegidos. Intuitivamente, evaluar que tan bueno es un test suite detectando fallas parece ser un buen criterio, sin embargo, salvo para fallas conocidas, no es posible realizar esta evaluaci\'on. La raz\'on de esto es que las fallas se definen en t\'erminos de su reparaci\'on, por ejemplo, \emph{falta incrementar la variable \texttt{i} al recorrer el arreglo}, no solo eso, sin\'o que se define en base a \emph{una} posible reparaci\'on, cuando en general, \'estas son infinitas. Criterios indirectos son entonces necesarios, \'estos definen metas a cubrir por los tests y eval\'uan cuantas son finalmente cubiertas. Estos criterios de cobertura se suelen dividir en dos categor\'ias principales: \emph{Caja blanca}(White box), cuando las metas a cubrir se basan en la estructura del programa; \emph{Caja negra}(Black box), cuando las metas se basan en las especificaciones. Ejecutar todas las sentencias en un programa, \emph{Cobertura de sentencias}, y, ejecutar todas las alternativas para las sentencias de control de flujo, \emph{Cobertura de ramas}, son ejemplos de caja blanca; determinar clases de equivalencia para las entradas del programa basado en su especificaci\'on y tener al menos un escenario por cada una de estas clases es un ejemplo de caja negra.

Un ejemplo de como los criterios de evaluaci\'on de test suite intentan dar una medida indirecta de la capacidad del mismo en detectar fallas potenciales, se puede apreciar en la cobertura de sentencias, este criterio impone como metas a cubrir, la ejecuci\'on de cada una de las sentencias del programa bajo evaluaci\'on. La intuici\'on del este criterio es bastante simple, lo m\'inimo y necesario para descubrir una falla, es ejecutar la sentencia o sentencias en donde se encuentra. Es sin embargo f\'acil de encontrar ejemplos de fallas simples en donde este criterio da una evaluaci\'on positiva a un conjunto de tests que es incapaz de detectar estos casos. Varios de estos ejemplos pueden ser detectados por un test suite que tenga una buena evaluaci\'on de parte del criterio de cobertura de ramas. Esto lleva a que evidentemente hay criterios que generan m\'as confianza que otros. Retomando la intuici\'on inicial de evaluar un test suite bajo su habilidad de detectar fallas, un criterio razonable y factible, es la de utilizar fallas artificiales, es decir, fallas conocidas, inyectadas en el programa para evaluar si las mismas son detectadas por el conjunto de test bajo evaluaci\'on. Esto sigue el razonamiento de que los programadores suelen crear programas que cuando tienen fallas, el programa no est\'a lejos de la soluci\'on correcta \cite{bibliography.mutation.DeMillo}, y por lo tanto, peque\~nos cambios sint\'acticos en un programa deber\'ian emular los errores que se suelen cometer en su desarrollo.

\emph{Mutation testing}, es un criterio que genera copias del programa original en donde cada uno tiene inyectada una falla artificial, \emph{mutante}, en forma de un cambio sint\'actico simple, \emph{mutaci\'on}. Por cada mutante se ejecutan los tests, si al menos uno de estos falla, entonces se marca al mutante como detectado. El valor asociado a este criterio es la relaci\'on entre mutantes detectados y todos los mutantes, \emph{mutation score}. Las fallas artificiales generadas por mutation testing est\'an basadas en distintos operadores de mutaci\'on que definen familias de cambios sint\'acticos similares. Por ejemplo, dada una expresi\'on relacional binaria, cambiar el operador de relaci\'on por cada uno de los existentes en el lenguaje en el cual el programa est\'a desarrollado, es un operador de mutaci\'on. Numerosos estudios han intentado responder si existe una correlaci\'on (acoplamiento) entre la capacidad de un test suite en detectar fallas artificiales utilizadas en mutation testing y la capacidad de hacerlo para fallas reales, entre ellos, \cite{bibliography.mutation.evaluation.coupling.Offutt89, bibliography.mutation.evaluation.coupling.Offutt92, bibliography.mutation.evaluation.HAndrews05, bibliography.mutation.evaluation.valid-substitute}, estos estudios han encontrado que de hecho existe una correlaci\'on, aunque siempre acotada a casos de estudio particulares. A\'un teniendo en cuenta estos resultados, el rendimiento del criterio est\'a directamente relacionado a los operadores de mutaci\'on utilizados y las fallas artificiales que estos generan. Por un lado la cantidad de mutantes impacta en los recursos necesarios para ejecutar el an\'alisis, ya que en el peor caso es necesario ejecutar todos los tests para cada uno de los mutantes. Por el otro lado, existen fallas artificiales que son trivialmente detectables, por ejemplo, modificar el \'indice en el acceso a un arreglo a un valor negativo, y aquellas que son equivalente al programa original. En el primer caso, ejecutar la sentencia va a causar un error, y cualquier test que lo haga va a detectar dicho mutante, este tipo de fallas triviales van a aumentar el mutation score sin realmente significar un aumento en la calidad del test suite. En el segundo caso, no existe ning\'un escenario para el cual el comportamiento del mutante difiera del comportamiento observable del programa original, en este caso el valor del mutation score va a decrementar sin significar un empeoramiento en el test suite. Finalmente as\'i como las fallas artificiales pueden estar acopladas a fallas reales, el mismo fen\'omeno puede ocurrir entre los mutantes, es decir, detectar ciertos mutantes va a implicar que otros sean tambi\'en detectados. Este caso de acoplamiento entre mutantes lleva a un aumento del mutation score que si bien puede estar asociado a fallas artificiales no triviales, son fallas similares que no implican que el test suite sea capaz de detectar mayor variedad de fallas reales.

Existen varios estudios que intentan atacar los problemas mencionados anteriormente, desde aquellos que lo hacen seleccionando un conjunto \emph{suficiente} de operadores de mutaci\'on \cite{bibliography.mutation.selection.Offutt96, bibliography.mutation.selection.ASN2008}; buscando m\'etodos para detectar mutantes equivalentes, \cite{biblography.mutation.evaluation.equivalent.Grun+09, biblography.mutation.evaluation.equivalent.Schuler+10, biblography.mutation.evaluation.equivalent.Schuler+13, biblography.mutation.evaluation.equivalent.Just+13}; y utilizando una combinaci\'on de mutaciones para generar mutantes sut\'iles bajo el razonamiento de que \'estos deber\'ian representar fallas m\'as dif\'iciles de detectar, \cite{bibliography.mutation.highorder.Jia+08, bibliography.mutation.highorder.Jia+09, bibliography.mutation.highorder.Harman+11}. Un resultado de especial inter\'es es el de Just et Al. \cite{bibliography.mutation.evaluation.valid-substitute} que una de sus conclusiones es que existen fallas reales que requieren mejorar operadores de mutaci\'on existentes, o desarrollar operadores nuevos.

%Metodológicamente, explicar en qué consiste tener una etapa de captura y especificación de requisitos concreta en el proceso de desarrollo.

%Etapa de análisis = captura y especificación de requisitos. Con qué contamos para hacerlo.Y captura? Varias herramientas vinculadas al “proceso”. Ej.: checklists, listas de preguntas frecuentes sobre el software a construir, etc. 

%Con qué contamos para hacerlo. Lenguaje natural, lenguajes de propósito específico (todo esto es especificación).
%Algunas herramientas metodológicas: Diagramas de estímulo/respuesta, DFDs y descomposición de funcionalidades, 4-variable model, KAOS. 

%natural 

%informales 

%Lenguaje natural vs. lenguajes formales para la especificación de requisitos. Sintaxis formal vs sintaxis+semántica. Posibilidades de análisis “objetivo” de specs, libre de interpretaciones subjetivas de las specs por parte de los ingenieros . Algunos antecedentes (mencionados superficialmente).

%Sintaxis + semántica formales facilitan análisis (semi-)automático vinculado a specs de requisitos. Qué se puede sistematizar? (algunos ejemplos de tareas).  Automático vs. asistido. Ejemplos de alto nivel, y mencionando sólo referencias, no trabajos concretos.
%Algunos ejemplos de trabajos explotando estas observaciones: referencias, descripciones superficiales.

%semi-automaticas 

%automaticas

% % % %


\section{Motivaci\'on y Objetivos}
\label{sec:intro.objetivos}
% RE etapa mas informal del proceso de desarrollo
% incertidumbre, desconocimiento, parcialidad.
%[operacional vs declarativo]

\begin{figure}[t]
	\begin{lstlisting}[frame=tlrb, mathescape=true]
    public class Queue {
	
      private Node front;
      private Node last;
	
      ...
      public void dequeue() {
        this.front = this.front.next;
      }
	
      public int size() {
        // computes number of nodes in the 
        // underlying list
        ...
      }
      ...
    }
	\end{lstlisting}
	\caption{Una implementaci\'on de colas basada en referencias.}
	\label{figures.motivation.queue-class}
\end{figure}

En la actualidad, los lenguajes orientados a objetos, o que contienen caracter\'isticas similares, tienen una presencia mayoritaria dentro de los lenguajes utilizados. Un tipo de expresi\'on com\'unmente encontrado en este tipo de lenguajes, son las expresiones de navegaci\'on. \'Estas se forman al acceder a miembros de instancias de clases mediante un operador de acceso que suele seguir la notaci\'on punto. Incluso con la popularidad de estos lenguajes, ning\'un operador actual, ni siquiera aquellos que pertenecen al grupo de \emph{operadores suficientes}, generan mutaciones para este tipo de expresiones. La necesidad de agregar operadores que generen mutaciones para \'estas, se puede ver con un ejemplo muy simple.

Dada una implementaci\'on (defectuosa) de una cola sobre cadenas simplemente encadenadas, con una referencia al \emph{primer} nodo y otra al \emph{\'ultimo}, y un m\'etodo \emph{dequeue()} tal como se muestra en la Figura-\ref{figures.motivation.queue-class}. Cualquier test que haga una llamada a este m\'etodo va a lograr una cobertura estructural (ramas por ejemplo) del 100\%.
%HERE===========
Ninguna de las herramientas actuales de mutation testing, por ejemplo, \emph{PITest}, \emph{Major}, y \emph{$\mu$Java}, generan mutaciones para el c\'odigo en \emph{desencolar()} haciendo que sea trivial para cualquiera de estos tests de lograr una cobertura de mutaci\'on. Por lo tanto, tener un \'unico test para este m\'etodo, como el siguiente:
\begin{center}
	\begin{lstlisting}[frame=tlrb, mathescape=true]
    @Test
    public void dequeueTest() {
      Queue q = new Queue();
      q.push(1);
      int size = q.size();
      q.dequeue();
      assertEquals(size - 1, q.size());
    }
	\end{lstlisting}
\end{center}
va a ser suficiente para lograr una cobertura (ramas) del 100\%, y cubrir de manera trivial todos los objetivos definidos por mutation testing.

En otro tipo de programas, en donde encadenamiento de m\'etodos (\emph{Method Chaining}) es muy utilizado, por ejemplo en el desarrollo de interfaces fluentes (\emph{Fluent Interfaces}). En donde se utiliza la jerarqu\'ia de clases, asociadas a los lenguajes orientados a objetos, para determinar una gram\'atica. Para entre otras cosas, poder definir un lenguaje de dominio espec\'ifico, como por ejemplo:
\begin{center}
	\begin{lstlisting}[mathescape=true]
	dbconnector.from("Songs").select().where()
	.attribute("year").ge().value(1980)
	.and()
	.attribute("year").lt().value(1990)
	.ejecute()
	\end{lstlisting}
\end{center}
En donde se muestra el uso de method chaining para escribir una consulta a la tabla "Songs" de la cual se van a seleccionar aquellas en donde el atributo "year" sea mayor o igual a 1980 y menor que 1990.

Un punto importante a notar en el ejemplo anterior es que si bien existen operadores relacionales que pueden modificar un "mayor o igual a" por otro operador, el caso de \texttt{attribute("year").ge().value(1980)}, es sem\'anticamente equivalente a \texttt{attribute("year") >= 1980} pero no puede ser mutado.

Esto nos lleva a nuestros objetivos:

\begin{enumerate}[leftmargin=.75cm,align=left]
	\item[Determinar las propiedades que un operador deber\'ia satisfacer]
	Dise\~nar un operador de mutaci\'on no es una tarea trivial, tal como mencionamos anteriormente, mutantes equivalentes al programa original son indeseados; aquellos que son trivialmente detectados tambi\'en; los mutantes generados deben representar, estar acoplados a, fallas reales. Definir estas propiedades es el primer paso para poder dise\~nar un nuevo operador.
	\item[Definir un operador de mutaci\'on para expresiones de navegaci\'on]
	Teniendo en cuenta las propiedades definidas anteriormente y la motivaci\'on para disen\~ar nuevo[s] operadores de mutaci\'on para expresiones de navegaci\'on, es necesario dar una definici\'on de su comportamiento.
	\item[Implementar el o los operadores de mutaci\'on para expresiones de navegaci\'on] 
	Los operadores existentes actualmente est\'an definidos por reglas de transformaci\'on muy simples, incluso siendo capaz de ser implementados usando expresiones regulares. Modificar una expresi\'on de navegaci\'on requiere informaci\'on de tipos y an\'alisis de alcanzabilidad para determinar las expresiones disponibles al modificar una existente.
	\item[Evaluaci\'on]
	Incluso si es cierto que existe una necesidad por la generaci\'on de mutantes para expresiones de navegaci\'on, si el o los operadores que los generan, no cumplen con las propiedades anteriormente descriptas, entonces su utilidad se ve muy reducida. Por eso es necesario evaluar el desempe\~no de \'estos para demostrar su utilidad.
\end{enumerate}

Como objetivo secundario nos interesa el aporte que puede tener la mutaci\'on de expresiones de navegaci\'on en campos como la reparaci\'on autom\'atica de programas basada en mutaci\'on.

%Objetivos

\section{Estado del Arte}
\label{sec:intro.estado-del-arte}
%Estado del arte en mutacion: selection, coupling, subsumption, high order
%Estado del arte en reparacion

Testing es una de las t\'ecnicas m\'as utilizadas para evaluar la correctitud de programas. Siendo testing de regresi\'on, la re-ejecuci\'on se tests para evaluar que el comportamiento correcto del programa no fue modificado durante el desarrollo, uno de los usos m\'as comunes. Es en este \'ultimo donde la limitaci\'on en los recursos a utilizar, tiempo por ejemplo, est\'an m\'as acotados, dado que el desarrollador necesita de manera r\'apida y eficiente validar que mantuvo el comportamiento existente. Esto lleva a buscar criterios de evaluaci\'on de test suites que permitan maximizar la eficiencia del mismo con respecto a capacidad de detectar fallas reales, manteniendo acotada la cantidad de tests requeridos.

Mutation testing es uno de los criterios m\'as utilizados. A la vez que al igual que con el test suite, el conjunto de mutantes utilizados debe mantenerse acotado en cantidad, debe ser capaz de evaluar al mismo de tal forma que la calidad asociada al conjunto de tests est\'e correlacionada con la capacidad del mismo en detectar potenciales fallas.

Dentro de las t\'ecnicas utilizadas para mejorar mutation testing se encuentran:

\texttt{Selection}, la selecci\'on de un subconjunto de operadores o mutantes es un \'area de investigaci\'on que intenta encontrar t\'ecnicas que permitan achicar el conjunto de mutantes con los cuales se va a evaluar el conjunto de tests. [AGREGAR]

\texttt{Coupling}, el acoplamiento entre fallas reales y mutantes es una propiedad altamente deseable, sin la misma, mutation testing perder\'ia su utilidad al desaparecer la correlaci\'on entre un mutation score alto y una buena capacidad de parte del test suite para detectar fallas reales. [AGREGAR]

\texttt{Subsumption}, as\'i como la correlaci\'on entre mutantes y fallas reales es una caracter\'istica deseada y buscada, lo mismo pero entre mutantes es una caracter\'istica negativa. Esta correlaci\'on entre mutantes significa que aquellos que lo est\'en, ser\'an redundantes, incrementando el mutation score sin actualmente resultar en un test suite con una mayor capacidad de detectar fallas. [AGREGAR]

\texttt{High Order}, la combinaci\'on de mutaciones, generada al aplicar operadores de mutaci\'on m\'as de una vez al generar un mutante, se denominan mutaciones de alto order mientras que aquellas que la forman, se las llama de primer orden. Si bien en principio esto agregar\'ia una gran cantidad de nuevos mutantes\footnote{Usualmente la cantidad de mutantes al aplicar m\'as de una mutaci\'on por mutante est\'a acotada por M$_0^G$ en donde \texttt{M$_0$} son la cantidad de mutantes de primer orden y \texttt{G} son la cantidad de mutaciones por mutante}, los estudios actuales que se enfocan en esta t\'ecnica concluyen que estos mutantes de alto orden representan fallas artificiales m\'as sutiles y que subsumen a una gran cantidad de mutantes de primer orden. [AGREGAR]

En reparaci\'on autom'atica de programas, una de los argumentos m\'as utilizados es que por un lado, cuando existe una falla, la versi\'on del programa sin la misma es muy cercana, sint\'acticamente, a la primera. Por otro lado el c\'odigo asociado a la reparaci\'on es, en muchos casos, una reorganizaci\'on (eliminaci\'on, desplazamiento, o duplicaci\'on) de c\'odigo existente; una alteraci\'on, es decir, un cambio sint\'actico, de c\'odigo existente; o una combinaci\'on de ambas. Dentro de t\'ecnicas de reparaci\'on asociadas mayormente a la primer categor\'ia se encuentran [AGREGAR]. La segunda categor\'ia est\'a muchas veces asociada a el uso de mutation dentro del contexto de reparaci\'on, el argumento es que existen mutaciones que si se fueran a combinar, se cancelar\'ian, por ejemplo:
\lstinline|for (int i = 0; i < lenght; i++)...| se puede mutar, aplicando un cambio de operador relacional, a \lstinline|for (int i = 0; i > lenght; i++)...|, que a su vez se puede mutar al c\'odigo original aplicando el mismo operador de mutaci\'on. Aunque no siempre se puede deshacer una mutaci\'on aplicando otra que sea sint\'acticamente inversa. Volviendo al ejemplo anterior, el mutante \lstinline|for (int i = 0; i > lenght; i++)...| se puede restaurar, sem\'anticamente, generando el mutante \lstinline|for (int i = 0; i != lenght; i++)...|. Existen tambi\'en casos donde varias mutaciones pueden restaurar el comportamiento. Esto lleva a la idea de que si consideramos el programa con fallas \texttt{P$_b$} y el original sin fallas \texttt{P$_o$}, se puede definir el segundo en t\'erminos del primero como \texttt{P$_b$ = mutate(P$_o$, M)} donde \texttt{M} representa una secuencia de mutaciones y \texttt{mutate} es un programa que aplica dicha secuencia a un programa. En general como dijimos anteriormente, toda mutaci\'on tiene su inversa, lo que lleva a definir el problema de reparaci\'on como encontrar una secuencia de mutaciones \texttt{M$\prime$} tal que \texttt{P$_o$ = mutate(P$_b$, M$\prime$)}. Herramientas que tratan este caso, el de reparar programas utilizando mutaci\'on o una combinaci\'on entre mutaci\'on y reorganizaci\'on de c\'odigo incluyen [AGREGAR]

\section{Contribuciones}
\label{sec:intro.contribuciones}
%TODO: Describir porque nuestras t\'ecnicas mejoran o complementan las t\'ecnicas de an\'alisis autom\'aticos existentes. Cuales y porque son los casos de estudios utilizados para validar cada una de las t\'ecnicas.
%\begin{itemize}
%\item operacionalizacion
%\item amplitud de objetivos (liveness)
%\item abstraccion
%\item escalabilidad
%\item herramientas
%\end{itemize}

%Se pueden mencionar papers publicados

La definici\'on e implementaci\'on de una familia de operadores de mutaci\'on para expresiones de navegaci\'on, dentro del contexto de mutation testing, es la principal contribuci\'on de este trabajo. Dado que la mutaci\'on de expresiones de navegaci\'on generar\'ia en principio una cantidad inmanejable de mutantes, es necesario encontrar y definir el tipo de fallas que se desean generar. Por otro lado, visto y considerando la gran cantidad de trabajo orientado a m\'etodos de selecci\'on para reducir la cantidad final de mutantes, y la simplificaci\'on del proceso de mutaci\'on en herramientas actuales para hacer de mutation testing una t\'ecnica m\'as r\'apida, nos lleva a la necesidad de evaluar no solo la generaci\'on de fallas artificiales previamente no representadas, sino tambi\'en que el rendimiento de mutation testing no se ve significativamente afectado de forma negativa al agregar estos operadores. Espef\'iciamente en esta tesis presentaremos las siguientes contribuciones principales:

\begin{enumerate}
	\item Mostrar la necesidad de generar mutantes para expresiones de navegaci\'on. El conjunto de \emph{operadores suficientes} de mutaci\'on, ha permanecido pr\'acticamente igual desde hace a\~nos, si bien el primer trabajo que ofrece un conjunto de operadores formalmente definidos lo hace para el lenguaje FORTRAN \cite{bibliography.mutation.definitions.fortranOffut87, bibliography.mutation.definitions.fortranKing91}, mutation testing fue siendo aplicado y evaluado en varios lenguajes incluyendo aquellos considerados orientados a objetos (ADA, JAVA, entre otros). Sin embargo los operadores de mutaci\'on espec\'ificos para lenguajes orientados a objetos solo afectan, en general, jerarqu\'ia de clases y sobre-escritura. En el trabajo de \cite{bibliography.mutation.evaluation.valid-substitute} se expone la necesidad de mejorar operadores de mutaci\'on o desarrollar nuevos para poder representar cierto tipos de fallas reales no representadas actualmente. Nuestra primer contribuci\'on es evidenciar la necesidad de representar fallas relacionadas a expresiones de navegaci\'on com\'unmente encontradas en lenguajes orientados a objetos.
	
	\item Dar una definici\'on formal de operadores para expresiones de navegaci\'on. Si bien la implementaci\'on que se ofrece en esta tesis es implementada en una herramienta espec\'ifica para un lenguaje particular, la definici\'on de los operadores deber\'ia permitir su implementaci\'on en cualquier herramienta y lenguaje. Una de las razones para esto incluye su utilizaci\'on para lenguajes de modelado, como Alloy \cite{bibliography.books.SoftwareAbstractions-alloy}, basados en trabajos como \cite{bibliography.repair.mutation.AlloyWang18} que propone una herramienta de reparaci\'on de modelos escritos en este lenguaje; \cite{bibliography.algebraicExpressions.RexGenWang18} que expone la necesidad de la generaci\'on autom\'atica de expresiones en \'algebra relacional para distintos campos, entre ellos, reparaci\'on autom\'atica y ayudas al desarrollador (tooltips autom\'aticos).
	
	\item Implementar la familia de operadores para expresiones de navegaci\'on. Nuestra implementaci\'on est\'a enfocada al lenguaje \emph{Java}, dado que es un buen representante de lenguajes orientados objetos. Nuestra implementaci\'on est\'a realizada en una versi\'on modificada de \emph{$\mu$Java} \cite{bibliography.mutation.tools.muJavaMaOK05}. Hemos aprovechado para implementar distintos an\'alisis que usaremos durante la evaluaci\'on como \emph{dureza}(toughness) que mide cuantos tests fue capaz de sobrevivir un mutante antes de ser detectado, este valor puede ser tomado como un indicador de cuan dif\'icil es detectar un mutante, y permitir\'ia sacar conclusiones sobre la dificultad de los mutantes generados por un operador; \emph{subsumci\'on}(subsumption) de mutantes, es un an\'alis que permite poner en evidencia para un programa particular, con un conjunto de tests particular, mutantes redundantes. Una caracter\'istica de nuestra implementaci\'on es la capacidad de configurar la familia de operadores para expresiones de navegaci\'on para poder proveer la mayor eficiencia para cada caso de estudio.
\end{enumerate}

Evaluaremos nuestra familia de operadores para expresiones de navegaci\'on bajo, mayormente, estructuras de datos [AGREGAR]. Contrastaremos el efecto de agregar estos operadores al conjunto suficiente de operadores definidos en la literatura y que se encuentran implementados en \emph{$mu$Java}. Es necesario considerar que nuestra versi\'on modificada de esta herramienta contiene numerosas mejoras a los operadores ya existentes, principalmente validaciones faltantes para evitar la generaci\'on de mutantes que no compilan (un subconjunto de los mutantes triviales) como por ejemplo no agregar el operador \texttt{++} a una expresi\'on constante.
[AGREGAR]


\section{Organizaci\'on}
\label{sec:intro.organizacion}
%TODO: Cuales van a ser los temas de cada capitulo desarrollado en este trabajo.


