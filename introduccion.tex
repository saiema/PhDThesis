%!TEX root = main.tex
\chapter{Introducci\'on}
\label{cap:introduccion}

En la actualidad, el software se encuentra en todos los aspectos de la vida diaria, y en general la expectativa del usuario es confiar en que el mismo simplemente funciona. Nadie espera que el autom\'ovil no arranque por un error en el software embebido que utiliza, o que el cajero autom\'atico de un banco no retorne billetes al realizar una extracci\'on v\'alida, o que el reloj del tel\'efono celular marque un horario incorrecto, etc. Sin embargo, son innumerables los ejemplos de errores de software, que causan comportamientos indebidos del mismo. Algunos de estos errores pueden ser catastr\'oficos. Algunos ejemplos son los siguientes. En 2015 se descubri\'o un bug en el modelo Boeing 787 Dreamliner que pod\'ia causar el apagado de todos los generadores el\'ectricos del avi\'on, si las unidades de control de los generadores permanec\'ian encendidas por m\'as de 248 d\'ias \cite{bibliography.bugs.boeing}. En los a\~nos 80, un error en el c\'odigo del controlador para la m\'aquina de terapia de radiaci\'on \emph{Therac-25}, caus\'o la muerte de varios pacientes al administrar cantidades excesivas de radiaci\'on beta \cite{bibliography.bugs.Therac25LevesonT93}. Otros ejemplos m\'as recientes (y menos cr\'iticos) incluyen el caso de un bug de WhatsApp, descubierto en 2018, que causaba que la aplicaci\'on, y en muchos casos el dispositivo, dejara de responder, si se recib\'ia un mensaje en Unicode, conteniendo una secuencia que repet\'ia cierto caracter especial (el caracter especial que especifica la direcci\'on de renderizado del texto).
%REF: BUG AVION: https://s3.amazonaws.com/public-inspection.federalregister.gov/2015-10066.pdf
%REF: THREAC-25, CITATION NEEDED?
%REF: BLACK DOT OF DEATH, CITATION NEEDED?

Claramente, suponer que el software simplemente funciona, es un error. Los errores en un programa pueden tener consecuencias que van desde una molestia menor al usuario, hasta la p\'erdida de vidas. Esto muestra la enorme relevancia del problema de garantizar la correcci\'on de un programa, es decir, la comprobaci\'on de que para todo escenario de uso, incluyendo las entradas directas e indirectas del software, el programa se comporta como se espera, o equivalentemente, que arroja el resultado esperado. Uno de los enfoques tradicionales y de mayor adopci\'on en la pr\'actica, para analizar la correcci\'on de un programa, es el \emph{testing}, que consiste en evaluar el comportamiento del programa en cuesti\'on en un conjunto espec\'ifico de escenarios de ejecuci\'on. Dado que la comprobaci\'on exhaustiva de todos los escenarios de ejecuci\'on es en general inviable salvo para programas muy simples, en la pr\'actica s\'olo un subconjunto de estos escenarios puede ser evaluado. Cu\'antos y cu\'ales de todos los escenarios se seleccionan est\'a directamente relacionado con la confianza que brindar\'a el proceso de testing de que el software funciona correctamente, cuando este proceso no encuentre fallas.

% No va aca
%No solamente es necesario un conjunto de escenarios, el comportamiento esperado requiere ser definido, y la forma m\'as simple es usando un valor esperado, por ejemplo, esperar que llamar a un m\'etodo \texttt{helloWorld()} retorne la cadena \emph{"Hello World"}; un ejemplo m\'as complejo es que luego de ejecutar el m\'etodo \texttt{insert(3)} sobre una lista vac\'ia, llamar al m\'etodo \texttt{contains(3)} retorne verdadero. Otra forma de evaluar el comportamiento esperado es evaluando propiedades, como un orden ascendente de los elementos en una lista simplemente encadenada, antes y despu\'es de ejecutar cualquier m\'etodo sobre la misma. Lo que define el comportamiento esperado es lo que se conoce como \emph{Or\'aculo}.

% No va aca
%Podemos entonces definir a un test, como una serie de pasos conteniendo tres partes principales: \emph{Preparaci\'on}(Arrange), consiste en definir o construir el escenario sobre el que se va a evaluar un programa; \emph{Ejecuci\'on}(Act), donde se va a ejecutar el programa a evaluar; \emph{Evaluaci\'on}(Assert), donde se va a evaluar el resultado obtenido contra el esperado.

Un conjunto de tests (los escenarios de ejecuci\'on del software bajo an\'alisis) debe ser necesariamente finito, lo cual implica que en general no es posible en la pr\'actica evaluar exhaustivamente una pieza de software en todos los posibles escenarios de ejecuci\'on. M\'as a\'un, la ejecuci\'on del software en los escenarios elegidos debe insumir recursos razonables; esto por supuesto va a depender del contexto y los recursos disponibles, pero en l\'ineas general es esperable que la ejecuci\'on de los casos de tests sea \emph{eficiente}, especialmente aquellos que el desarrollador utiliza como apoyo constante a sus actividades de programaci\'on. 

%No va aca
%finalmente el \'exito en la execuci\'on de estos tests, es decir, que ninguno detecte una diferencia entre el resultado obtenido y el esperado, deber\'ia servir como control de calidad del software.

Dado que la finalidad del testing es evaluar un programa en un subconjunto de todos sus escenarios posibles, como forma aproximada de estimar (a trav\'es de una generalizaci\'on) su correcto comportamiento en el universo de todos los escenarios de ejecuci\'on, es necesario contar con un criterio para evaluar la calidad del conjunto elegido, es decir, evaluar cu\'an bien un conjunto de escenarios representa el universo de \'estos. Intuitivamente, un buen conjunto de casos de tests, o \emph{test suite}, es aquel que tiene una alta capacidad de detectar fallas: si existe un bug en el programa, alg\'un test en la suite es capaz de detectarlo. Sin embargo, esta intuici\'on, como criterio para evaluar cu\'an buena es una suite, es viable s\'olo si uno conoce de antemano los bugs del programa bajo an\'alisis. 
% No tiene sentido aca, y no se entiende
%La raz\'on de esto es que las fallas se definen en t\'erminos de su reparaci\'on, por ejemplo, \emph{falta incrementar la variable \texttt{i} al recorrer el arreglo}, no solo eso, sin\'o que se define en base a \emph{una} posible reparaci\'on, cuando en general, \'estas son infinitas. 
Resulta necesario entonces utilizar criterios indirectos, para medir la calidad de suites de tests. Estos criterios definen en general metas o requisitos a cubrir por los tests, a partir de los cuales se puede \emph{medir} cu\'antos son efectivamente cubiertos. Estos criterios de evaluaci\'on se suelen dividir en dos categor\'ias principales: \emph{caja blanca} (white box), cuando las metas a cubrir se basan en la estructura del programa, y \emph{caja negra} (black box), cuando las metas se basan en las especificaciones. Algunos ejemplos t\'ipicos de criterios de caja blanca son la \emph{cobertura de sentencias}, que exige ejecutar a trav\'es de la suite todas las sentencias en un programa, y \emph{cobertura de ramas}, que exige ejecutar todas las alternativas para las sentencias de control de flujo. Determinar clases de equivalencia para las entradas del programa basado en su especificaci\'on, y tener al menos un escenario por cada una de estas clases, es un ejemplo de un criterio de caja negra (denominado \emph{particionado en clases de equivalencia}).

Un ejemplo de c\'omo los criterios de evaluaci\'on de test suites intentan dar una medida indirecta de la capacidad de las mismas en detectar fallas potenciales se puede apreciar en la cobertura de sentencias. Este criterio impone, como metas a cubrir, la ejecuci\'on de cada una de las sentencias del programa bajo evaluaci\'on. La intuici\'on de este criterio es bastante simple: lo m\'inimo indispensable para descubrir una falla, es ejecutar la sentencia o sentencias donde se encuentra el defecto asociado a la misma. Es sin embargo f\'acil encontrar ejemplos de fallas simples donde este criterio da una evaluaci\'on positiva a un conjunto de tests, y a\'un as\'i este conjunto sea incapaz de detectar fallas. Varios de estos ejemplos pueden ser detectados por una test suite que tenga una buena evaluaci\'on con respecto al criterio de cobertura de ramas. Esto lleva a que evidentemente hay criterios que generan m\'as confianza que otros, o equivalentemente, que imponen requisitos m\'as fuertes a las test suites. 

Retomando la intuici\'on inicial de evaluar una test suite con respecto a su habilidad de detectar fallas, un criterio razonable y factible es el de utilizar fallas artificiales, es decir, fallas conocidas, inyectadas en el programa, para evaluar si las mismas son detectadas por el conjunto de tests bajo evaluaci\'on. Esta idea se basa en el razonamiento de que los programadores suelen crear programas, que cuando tienen fallas, no est\'an lejos de una soluci\'on correcta correspondiente \cite{bibliography.mutation.DeMillo}, y por lo tanto peque\~nos cambios sint\'acticos en un programa deber\'ian emular los errores que se suelen cometer en su desarrollo. \emph{Mutation testing} es un criterio de testing basado en esta idea. El mismo se basa en generar copias del programa original, donde cada una, denominada \emph{mutante}, tiene inyectada una falla artificial en forma de un cambio sint\'actico simple, denominado \emph{mutaci\'on}. Por cada mutante se ejecutan los tests, y si al menos uno de \'estos falla, entonces se marca al mutante como detectado. El valor asociado a este criterio, denominado \emph{mutation score}, es la relaci\'on entre mutantes detectados y todos los generados. Las fallas artificiales generadas por mutation testing est\'an basadas en distintos operadores de mutaci\'on, que definen familias de cambios sint\'acticos similares. Por ejemplo, dada una expresi\'on relacional binaria, cambiar el operador de relaci\'on por cada uno de los existentes en el lenguaje en el cual el programa est\'a desarrollado, es un operador de mutaci\'on (es decir, cambiar por ejemplo un operador como $<$ por todas las alternativas de comparaci\'on, $==$, $\le$, $\ge$, etc., generando por cada una un mutante diferente). Numerosos estudios han intentado responder si existe una correlaci\'on (acoplamiento) entre la capacidad de una test suite en detectar fallas artificiales, utilizadas en mutation testing, y la capacidad de hacerlo para fallas reales \cite{bibliography.mutation.evaluation.coupling.Offutt89, bibliography.mutation.evaluation.coupling.Offutt92, bibliography.mutation.evaluation.HAndrews05, bibliography.mutation.evaluation.valid-substitute}. Estos estudios han encontrado que de hecho existe una correlaci\'on, aunque siempre acotada a casos de estudio particulares. A\'un teniendo en cuenta estos resultados, el rendimiento del criterio est\'a directamente relacionado a los operadores de mutaci\'on utilizados, y las fallas artificiales que \'estos generan. Por un lado, la cantidad de mutantes impacta en los recursos necesarios para ejecutar el an\'alisis, ya que en el peor caso es necesario ejecutar todos los tests para cada uno de los mutantes. Por otro lado, existen fallas artificiales que son poco deseables para los prop\'ositos de mutation testing, o bien porque son trivialmente detectables (por ejemplo, en ciertos lenguajes, modificar el \'indice en el acceso a un arreglo a un valor negativo) o porque dan lugar a programas sem\'anticamente equivalentes al programa original (por ejemplo, realizar un incremento \emph{a posteriori}, o post-incremento, en una variable local en la sentencia de retorno de un m\'etodo). En el primer caso, ejecutar la sentencia va a causar un error, y cualquier test que lo haga va a detectar dicho mutante; este tipo de fallas triviales va a aumentar el mutation score sin realmente implicar un aumento en la calidad de la test suite. En el segundo caso, no existe ning\'un escenario para el cual el comportamiento del mutante difiera del comportamiento observable del programa original, causando un decremento en el valor del mutation score, sin significar un empeoramiento en la test suite. Finalmente, as\'i como las fallas artificiales pueden estar acopladas a fallas reales, el mismo fen\'omeno puede ocurrir entre los mutantes. M\'as precisamente, detectar ciertos mutantes va a implicar que otros sean tambi\'en detectados. Este tipo de acoplamiento entre mutantes lleva a un aumento del mutation score, que si bien puede estar asociado a fallas artificiales no triviales, al ser \'estas similares, no implican que la test suite sea capaz de detectar una mayor variedad de fallas reales.

Existen varios estudios que intentan atacar los problemas mencionados anteriormente, incluyendo aquellos que lo hacen seleccionando un conjunto \emph{suficiente} de operadores de mutaci\'on \cite{bibliography.mutation.selection.Offutt96, bibliography.mutation.selection.ASN2008}; otros que buscan m\'etodos para detectar mutantes equivalentes \cite{biblography.mutation.evaluation.equivalent.Grun+09, biblography.mutation.evaluation.equivalent.Schuler+10, biblography.mutation.evaluation.equivalent.Just+13}, y otros que utilizan una combinaci\'on de mutaciones para generar mutantes sutiles bajo el razonamiento de que \'estos deber\'ian representar fallas m\'as dif\'iciles de detectar \cite{bibliography.mutation.highorder.Jia+08, bibliography.mutation.highorder.Jia+09, bibliography.mutation.highorder.Harman+11}. Un estudio particularmente interesante, y relevante para los objetivos de esta tesis, es el que se presenta en \cite{bibliography.mutation.evaluation.valid-substitute}, cuyas conclusiones incluyen el hecho de que existen fallas reales que requieren mejorar operadores de mutaci\'on existentes, o desarrollar operadores nuevos (adem\'as de mostrar que mutation testing es un criterio que mantiene una mayor correlaci\'on con la detecci\'on de bugs reales que los criterios tradicionales de caja blanca). Esto expone la necesidad de mejorar operadores de mutaci\'on o desarrollar nuevos operadores, para poder representar a estos tipos de fallas reales no representadas actualmente por operadores existentes.

Adem\'as de la aplicaci\'on tradicional de operadores de mutaci\'on para mutation testing, recientemente ha surgido un \'area dentro de la Ingenier\'ia de Software que le da utilidad a estos operadores, invirtiendo su aplicaci\'on respecto a mutation testing: dado un programa incorrecto, es decir, que no cumple con la especificaci\'on asociada al mismo, se aplican mutaciones al programa con la finalidad de intentar \emph{repararlo}. Esta \'area, denominada \emph{reparaci\'on autom\'atica de programas} \cite{DBLP:journals/cacm/Harman10}, encuentra una nueva aplicaci\'on a los operadores de mutaci\'on, y de hecho da lugar a nuevas formas de mutaci\'on, que podr\'iamos describir como de ``granularidad gruesa'', que alteran la estructura de programa de manera m\'as dr\'astica, replicando bloques de c\'odigo, eliminando e intercambiando bloques de c\'odigo, etc \cite{bibliography.repair.GouesNFW12}. De la misma forma que en el contexto de mutation testing los operadores de mutaci\'on especificamente utilizados impactan en la calidad de la evaluaci\'on que mutation testing brinda, en el contexto de reparaci\'on de programas los operadores utilizados afectan tanto la eficiencia del proceso de reparaci\'on, como la efectividad del mismo. A diferencia de mutation testing, en reparaci\'on de programas los operadores de mutaci\'on suelen requerir m\'ultiples aplicaciones (reparar un programa suele requerir m\'ultiples alteraciones al programa original), y por lo tanto contar con muchos operadores de mutaci\'on da lugar a una explosi\'on en las reparaciones ``candidatas''; por otra parte, contar con pocos operadores de mutaci\'on disminuye las chances de reparar programas \cite{bibliography.repair.GouesNFW12}. Nuevamente, existen diversas formas de enfrentar estos problemas, desde los que consideran \emph{s\'olo} mutaciones de granularidad gruesa \cite{bibliography.repair.GouesNFW12}, o producen mutaciones imitando reparaciones realizadas por desarrolladores \cite{bibliography.repair.KimNSK13}, hasta los que sustituyen la exploraci\'on exhaustiva (acotada) de reparaciones candidatas por b\'usquedas guiadas \cite{bibliography.repair.GouesNFW12,bibliography.repair.StaberJB05,bibliography.repair.ArcuriY08}. Destacamos c\'omo, en el contexto de reparaci\'on de programas, surge nuevamente el problema del dise\~no y la construcci\'on de operadores de mutaci\'on.    


\section{Motivaci\'on y Objetivos}
\label{sec:intro.objetivos}


\begin{figure}[t]
	\begin{lstlisting}[frame=tlrb, mathescape=true, language=Java]
    public class Queue {
	
      private Node front;
      private Node last;
	
      ...
      public void dequeue() {
        this.front = this.front.next;
      }
	
      public int size() {
        // computes number of nodes in the 
        // underlying list
        ...
      }
      ...
    }
	\end{lstlisting}
	\caption{Una implementaci\'on de colas basada en referencias.}
	\label{figures.motivation.queue-class}
\end{figure}

En la actualidad, los lenguajes orientados a objetos, o que contienen caracter\'isticas de orientaci\'on a objetos, tienen una significativa relevancia dentro del espectro de los lenguajes de programaci\'on m\'as utilizados. Un tipo de expresi\'on com\'unmente encontrado en este tipo de lenguajes son las \emph{expresiones de navegaci\'on}. \'Estas se forman al acceder a miembros de clases (campos y m\'etodos) mediante un operador de acceso que suele seguir la notaci\'on punto. Desde la perspectiva de mutation testing, cabe resaltar que incluso con la popularidad de los lenguajes orientados a objetos, y la importancia de las expresiones de navegaci\'on en estos lenguajes, ning\'un operador de mutaci\'on actual, en particular ninguno de aquellos que pertenecen al grupo de \emph{operadores suficientes}, generan mutaciones para este tipo de expresiones. Por supuesto esto podr\'ia deberse a la suficiencia de los operadores de mutaci\'on tradicionales, y la irrelevancia de operadores de mutaci\'on para expresiones de navegaci\'on, a pesar de la importancia de estas expresiones en programas orientados a objetos. Veremos sin embargo, a trav\'es de un simple ejemplo, la necesidad de agregar operadores que generen mutaciones para expresiones de navegaci\'on.

Consideremos una implementaci\'on de una cola sobre una lista simplemente encadenada ac\'iclica, con una referencia al primer nodo, \emph{front}, y otra al \'ultimo, \emph{last}, y un m\'etodo \emph{dequeue()}, tal como se muestra en la Figura~\ref{figures.motivation.queue-class}. Notemos que esta implementaci\'on es defectuosa, dado que no trata adecuadamente los casos en los cuales la cola est\'a vac\'ia o consta de un \'unico elemento. Desde el punto de vista de los criterios cl\'asicos de caja blanca, y dado que la implementaci\'on de este m\'etodo no contiene bifurcaciones en su flujo de control, cualquier test que haga una llamada a este m\'etodo va a lograr una cobertura estructural (ramas, por ejemplo) del 100\%. En lo que respecta a mutation testing, cabe resaltar que ninguna de las herramientas modernas de mutation testing, por ejemplo, \emph{PITest}, \emph{Major}, o \emph{$\mu$Java}, generan mutaciones para el c\'odigo en \emph{dequeue()}. Luego, resulta trivial para cualquier test lograr una ``cobertura'' perfecta de mutaci\'on. Concretamente, tener un \'unico test para este m\'etodo, como el siguiente:

\begin{center}
	\begin{lstlisting}[frame=tlrb, mathescape=true, language=Java]
    @Test
    public void dequeueTest() {
      Queue q = new Queue();
      q.enqueue(1);
      int size = q.size();
      q.dequeue();
      assertEquals(size - 1, q.size());
    }
	\end{lstlisting}
\end{center}
resulta suficiente para lograr una cobertura (ramas) del 100\%, y cubrir de manera trivial todos los objetivos definidos por mutation testing.

Evidentemente, el problema en este caso se debe a que, en el contexto de mutation testing, ning\'un operador de mutaci\'on es capaz de mutar el cuerpo de \emph{dequeue()}. Por lo tanto, este criterio falla en imponer cualquier requisito (metas de cobertura) a la test suite. Si las expresiones de este tipo fueran raramente encontradas en programas actuales, podr\'iamos simplemente considerar a este problema poco importante, e ignorarlo. Pero las expresiones de navegaci\'on, del estilo de las que constituyen el cuerpo de \emph{dequeue()}, son muy comunes en programas que utilizan lenguajes orientados a objetos. Es m\'as, algunos patrones de dise\~no, populares en lenguajes orientados a objetos, como \emph{Builder}, o \emph{Fluent Interfaces}, hacen uso sustancial de expresiones de navegaci\'on.

Consideremos por ejemplo el patr\'on \emph{Builder}. Este patr\'on es utilizado para construir instancias de objetos que suelen contener una gran cantidad de atributos opcionales, sin la necesidad de definir en la clase correspondiente un alto n\'umero de constructores distintos. M\'as a\'un, este patr\'on permite tambi\'en que la construcci\'on de un objeto complejo sea legible, en el c\'odigo fuente. Un ejemplo de una biblioteca que utiliza este patr\'on es \emph{Apache Commons CLI}, una biblioteca para manejar los argumentos de entrada de una aplicaci\'on con interfaz de l\'inea de comandos. Un ejemplo del uso de \'esta se muestra a continuaci\'on:
\begin{center}
	\begin{lstlisting}[mathescape=true, language=Java,showstringspaces=false]
    Option inputOption = Option.builder("V")
      .longOpt("Value")
      .desc("The input value")
      .hasArg(true)
      .numberOfArgs(1)
      .type(Integer.class)
      .required(true)
      .build();
	\end{lstlisting}
\end{center}
Este ejemplo muestra la creaci\'on de un argumento para un programa que utiliza \texttt{-V} o \texttt{--Value} para hacer referencia al argumento; define una descripci\'on del mismo (\texttt{The input value}), especifica que el argumento requiere un \'unico valor asociado, de tipo entero, y que el argumento es obligatorio. Un ejemplo de uso de esa opci\'on ser\'ia:
\begin{lstlisting}
  miPrograma --Value 42
\end{lstlisting}

Otro patr\'on que realiza una utilizaci\'on extensiva de expresiones de navegaci\'on es \emph{Fluent Interfaces}, o interfaces fluentes. El mismo permite organizar programas alrededor de la utilizaci\'on de una jerarqu\'ia de clases (asociada a los lenguajes orientados a objetos), para definir una \emph{gram\'atica}, que permita caracterizar un lenguaje de dominio espec\'ifico. Veamos aqu\'i un ejemplo, con una biblioteca de SQL en Java:
\begin{center}
	\begin{lstlisting}[mathescape=true, language=Java]
	dbconnector.from("Songs").select().where()
	.attribute("year").ge().value(1980)
	.and()
	.attribute("year").lt().value(1990)
	.execute();
	\end{lstlisting}
\end{center}
En este ejemplo se muestra el uso de \emph{method chaining} para escribir una consulta a la tabla \emph{Songs}, de la cual se van a seleccionar aquellas entradas en las cuales el atributo \emph{year} sea mayor o igual a 1980 y menor que 1990.

Un punto importante a destacar en relaci\'on al ejemplo anterior es que si bien existen operadores relacionales que pueden modificar un ``mayor o igual a'' por otro operador, el caso de \texttt{attribute(``year'').ge().value(1980)}, que intuitivamente representa \texttt{year >= 1980}, no puede ser mutado.

El conjunto de \emph{operadores suficientes} de mutaci\'on ha permanecido pr\'acticamente inalterado desde hace a\~nos, a\'un cuando el primer trabajo que ofrece un conjunto de operadores formalmente definido lo hace para el lenguaje Fortran \cite{bibliography.mutation.definitions.fortranOffut87, bibliography.mutation.definitions.fortranKing91}. Mutation testing ha sido aplicado y evaluado en varios lenguajes, incluyendo aquellos considerados orientados a objetos como Ada y Java, por dar un par de ejemplos. Sin embargo los operadores de mutaci\'on espec\'ificos para lenguajes orientados a objetos s\'olo afectan, en general, jerarqu\'ias de clases, visibilidad, y sobre-escritura. 

Un problema similar, en relaci\'on a las expresiones de navegaci\'on, se observa en el contexto de reparaci\'on de programas. Consideremos nuevamente la implementaci\'on de colas sobre listas enlazadas ac\'iclicas, y el c\'odigo del m\'etodo \emph{enqueue()} que se muestra a continuaci\'on:
\begin{lstlisting}[frame=tlrb, mathescape=true, language=Java]
public void enqueue(int elem) {
        QueueNode newNode = new QueueNode(elem);
        if (front == null) {
            front = newNode;
            last = newNode;
        } else {
            front.next = newNode;
            last = newNode;
        }
        size++;
}
\end{lstlisting}
Esta implementaci\'on es err\'onea dado que, cuando la cola no est\'a vac\'ia, inserta el nuevo elemento como el siguiente del comienzo, en lugar de insertar al final, como exige la pol\'itica de visita de elementos en una cola. El error y su reparaci\'on son simples: la expresi\'on \texttt{front.next = newNode} deber\'ia en realidad ser \texttt{last.next = newNode}. Sin embargo, herramientas de reparaci\'on autom\'atica como GenProg son incapaces de reparar este c\'odigo, pues sus mutaciones de granularidad gruesa no consiguen reproducir el comportamiento esperado para \emph{enqueue()}. 

Esto nos lleva a nuestros objetivos:

\begin{enumerate}[leftmargin=.75cm,align=left,style=nextline]
	\item[\textbf{Analizar las caracter\'isticas que un operador de mutaci\'on debe poseer}] Dise\~nar un operador de mutaci\'on no es una tarea trivial. Tal como mencionamos anteriormente, mutantes equivalentes al programa original son indeseados, as\'i como aquellos que son trivialmente detectados; los mutantes generados deben representar (o estar acoplados a) fallas reales. La aplicaci\'on de operadores de mutaci\'on para reparaci\'on introduce caracter\'isticas adicionales sobre los operadores de mutaci\'on, algunas contrapuestas a las de mutaci\'on para testing. De esta manera, nuestro primer objetivo es caracterizar las propiedades que un operador de mutaci\'on debe poseer, y definir \'estas de manera precisa, acompa\~nadas de mecanismos para su evaluaci\'on objetiva. 
	
	\item[\textbf{Definir un operador de mutaci\'on para expresiones de navegaci\'on}]\mbox{}\\
	Teniendo en cuenta las caracter\'isticas surgidas en el punto anterior, y bas\'andose en la motivaci\'on para dise\~nar nuevo[s] operadores de mutaci\'on para expresiones de navegaci\'on, nuestro segundo objetivo es dar una definici\'on de un nuevo operador que satisfaga esta necesidad, y que cumpla con las caracter\'isticas identificadas. M\'as a\'un, en la medida de lo posible, esta definici\'on debe ser agn\'ostica al lenguaje de programaci\'on utilizado para implementarlo.
	
	\item[\textbf{Implementar el operador de mutaci\'on para expresiones de navegaci\'on}] Los operadores existentes actualmente est\'an definidos por reglas de transformaci\'on muy simples, incluso pudiendo ser implementados usando expresiones regulares. Modificar una expresi\'on de navegaci\'on requiere informaci\'on de tipos y an\'alisis de alcanzabilidad para determinar las expresiones disponibles al modificar una existente. Nuestro tercer objetivo es entonces encontrar una herramienta de mutaci\'on que permita realizar el an\'alisis necesario para generar estas mutaciones; elegir un lenguaje sobre el cual y para el cual implementar este operador; e implementar tanto el operador como herramientas u extensiones que permitan realizar los an\'alisis apropiados para las evaluaciones necesarias a nuestro operador.
	
	\item[\textbf{Aplicaciones e impacto del operador de mutaci\'on en testing}]\mbox{}\\
	Incluso si es cierto que existe una necesidad por la generaci\'on de mutantes para expresiones de navegaci\'on, si el o los operadores que los generan no cumplen con las propiedades anteriormente descriptas, entonces su utilidad se ve muy reducida. Por eso, otro de nuestros objetivos es evaluar el desempe\~no de nuestro operador para analizar su utilidad e impacto de su incorporaci\'on como operador de mutaci\'on, en mutation testing. 
	
    \item[\textbf{Aplicaciones del operador de mutaci\'on en reparaci\'on}]\mbox{}\\
	Si bien el \'enfasis principal en esta tesis estar\'a alrededor de la introducci\'on de operadores de mutaci\'on para testing, analizaremos tambi\'en la aplicaci\'on de operadores de mutaci\'on de granularidad fina en el contexto de reparaci\'on autom\'atica de programas (en contraposici\'on con operadores de mutaci\'on tradicionales en reparaci\'on, que optan por una granularidad gruesa). En particular, analizaremos errores comunes en programas orientados a objetos, que tienen que ver con el uso de expresiones de navegaci\'on, y c\'omo el operador de mutaci\'on a introducir contribuye a su reparabilidad. En este proceso, analizaremos y discutiremos el rol de las especificaciones en la reparaci\'on autom\'atica de programas, y las limitaciones del uso de tests para suplantarlas. 
\end{enumerate}

%Objetivos

\section{Contribuciones}
\label{sec:intro.contribuciones}

%Se pueden mencionar papers publicados

La definici\'on e implementaci\'on de un operador de mutaci\'on, altamente configurable, para expresiones de navegaci\'on, dentro del contexto de mutation testing pero tambi\'en aplicable a reparaci\'on de programas, es la principal contribuci\'on de este trabajo. Dado que la mutaci\'on de expresiones de navegaci\'on generar\'ia en principio una cantidad inmanejable de mutantes, es necesario encontrar y definir el tipo de fallas que se desean generar (o alternativamente, el tipo de reparaciones candidatas, para el contexto de reparaci\'on). A\'un cuando la generaci\'on de mutantes para expresiones de navegaci\'on pudiera representar un conjunto de fallas no representadas por operadores de mutaci\'on existentes, no es necesariamente beneficioso generar tales mutaciones: en el caso particular de testing de mutaci\'on, debemos comprobar que la generaci\'on de tales mutaciones contribuye al an\'alisis, m\'as precisamente, no afecta negativamente el an\'alisis de mutaci\'on produciendo mutantes d\'ebiles (f\'aciles de matar y consecuentemente incrementando artificialmente el mutation score), ni mutantes ``acoplados'' a otros mutantes tradicionales (es decir, que se vean representados por otras mutaciones), ni un n\'umero alto de mutantes equivalentes (imposibles de ``matar'', dado que equivalen al programa original, y que por lo tanto disminuyen artificialmente el mutation score). De la misma manera, deberemos comprobar, en el contexto de reparaci\'on autom\'atica de programas, que la incorporaci\'on de mutaciones para expresiones de navegaci\'on incrementa la ``reparabilidad'', es decir, ayuda a reparar programas que, sin estas mutaciones, no pueden ser reparados o sus reparaciones son m\'as dif\'iciles de construir o encontrar. Espec\'ificamente, en esta tesis presentaremos las siguientes contribuciones principales:

\begin{enumerate}
	\item Introduciremos un operador de mutaci\'on para expresiones de navegaci\'on. Este operador estar\'a definido de manera precisa, y ser\'a configurable en una variedad de aspectos. M\'as a\'un, si bien la implementaci\'on que se ofrece en esta tesis se provee para un lenguaje particular, la definici\'on del operador permite su implementaci\'on para cualquier lenguaje con expresiones de navegaci\'on. Esto es particularmente relevante para el caso de lenguajes de modelado, como Alloy \cite{bibliography.books.SoftwareAbstractions-alloy}, en cuyo contexto se ha identificado la necesidad de ``mutar'' expresiones, como en \cite{bibliography.repair.mutation.AlloyWang18}, que propone una herramienta de reparaci\'on de modelos escritos en este lenguaje, y \cite{bibliography.algebraicExpressions.RexGenWang18}, que expone la necesidad de la generaci\'on autom\'atica de expresiones en \'algebra relacional para distintos prop\'ositos, entre ellos reparaci\'on autom\'atica y ayudas al desarrollador (tooltips autom\'aticos).
	
	\item Implementaremos el operador para expresiones de navegaci\'on, enfoc\'andonos en un lenguaje de programaci\'on particular, \emph{Java}. Elegimos este lenguaje porque lo consideramos un buen representante de lenguajes orientados a objetos. La implementaci\'on estar\'a basada en una versi\'on modificada de \emph{$\mu$Java} \cite{bibliography.mutation.tools.muJavaMaOK05}, que denominamos \emph{$\mu$Java++}, y que nos permite realizar an\'alisis de tipos y alcanzabilidad que otras herramientas no permiten. Como veremos m\'as adelante, generar mutaciones para expresiones de navegaci\'on requiere una cantidad significativa de ``fine tuning'', para maximizar las fallas reales representadas, minimizando caracter\'isticas no deseadas, entre ellas la explosi\'on en el n\'umero de mutantes generados. Por esto, nuestra implementaci\'on del operador de mutaci\'on funciona como un ``meta-operador'', el cual, mediante una amplia gama de configuraciones, puede verse como una familia de operadores de mutaci\'on (uno por cada configuraci\'on particular). 

    \item Una evaluaci\'on detallada del impacto de la incorporaci\'on de mutaciones para expresiones de navegaci\'on, en el contexto de mutation testing. Esta evaluaci\'on involucrar\'a una serie de implementaciones orientadas a objetos, test suites variadas para las mismas, sobre las cuales se analizar\'an distintas m\'etricas (que forman parte de nuestra implementaci\'on): \emph{dureza} (toughness), cuyo prop\'osito es medir cu\'an dif\'icil de matar resulta un mutante, a trav\'es de la medici\'on del n\'umero de tests a los cuales fue capaz de sobrevivir un mutante antes de ser detectado (este valor es relevante para realizar an\'alisis sobre la dificultad de matar los mutantes generados por un operador); \emph{subsumci\'on} (subsumption) de mutantes, que permite poner en evidencia, para un programa particular y con un conjunto de tests espec\'ifico, qu\'e mutantes resultan ``redundantes''; entre otras. 

    \item Una evaluaci\'on de la viabilidad de la incorporaci\'on de mutaciones para expresiones de navegaci\'on, en conjunto con otras mutaciones de ``granularidad fina'', en el contexto de reparaci\'on autom\'atica de programas. En particular, evaluaremos la reparabilidad de programas a trav\'es de estas mutaciones, y la viabilidad en t\'erminos de eficiencia, de la reparaci\'on con tales mutaciones. En relaci\'on a esta contribuci\'on, analizaremos tambi\'en la importancia de las especificaciones en la reparaci\'on autom\'atica de programas, y las limitaciones del uso de tests para suplantarlas en este contexto. 
 
\end{enumerate}

%TODO: mover a donde corresponda
La relaci\'on entre las fallas artificiales generadas por los operadores de mutaci\'on utilizados en mutation testing, y las fallas reales cuya detecci\'on representa el objetivo final de una test suite, ha sido estudiado con resultados positivos hacia la existencia de esta relaci\'on \cite{bibliography.mutation.evaluation.DaranT96, bibliography.mutation.evaluation.isMutationAppropiateAndrewsBL05, bibliography.mutation.evaluation.mutationInTestingExperimentsNaminK11} aunque es en el trabajo de Just et al \cite{bibliography.mutation.evaluation.valid-substitute} en donde no solamente consideran casos de estudios de mayor tama\~no (entre otras consideraciones que los trabajos previos no contemplaban) sin\'o tambi\'en un an\'alisis m\'as profundo que resulta en grupos de fallas reales para los cuales finalmente reportan si \'estos se encuentran acopladas a mutantes generados por operadores en el conjunto suficiente, o si es necesario mejorar o definir nuevos operadores que los representen. Este trabajo nos significa (como veremos m\'as adelante) una base muy importante para mostrar la necesidad de nuestro operador para expresiones de navegaci\'on.

%No va aca
%Evaluaremos nuestro operador bajo las siguientes colecciones implementadas y utilizando caracter\'isticas de programaci\'on orientada a objetos: \emph{TreeList}, una implementaci\'on de listas basada en \'arboles; \emph{NodeCachingList}, una lista encadenada con una cache de nodos; \emph{AvlTree}, una implementaci\'on cl\'asica de \'arboles balanceados; \emph{BinomialHeap}, una implementaci\'on de mont\'iculos basada en referencias; \emph{TreeSet}, una implementaci\'on de conjuntos basada en \'arboles rojos y negros; y \emph{BSTree}, una implementaci\'on de \'arboles binarios de b\'usqueda. Los experimentos fueron corridos en computadoras utilizando Intel Core i7 7700HQ CPUs a 2.8GHz, 16Gb de RAM, corriendo bajo GNU/Linux. Contrastaremos el efecto de agregar este operador al conjunto suficiente de operadores definidos en la literatura y que se encuentran implementados en \emph{$mu$Java++}. Es necesario considerar que nuestra versi\'on de esta herramienta contiene numerosas mejoras a los operadores ya existentes en la versi\'on original, \emph{$\mu$Java}, principalmente validaciones faltantes para evitar la generaci\'on de mutantes que no compilan (un subconjunto de los mutantes triviales), como por ejemplo no agregar el operador \texttt{++} a una expresi\'on constante.

%A su vez, mostraremos el uso de \emph{prvo} en el contexto de reparaci\'on autom\'atica de programas, y como ciertas fallas solo pueden ser reparadas al considerar al mismo.

\section{Organizaci\'on}
\label{sec:intro.organizacion}

El resto de esta tesis est\'a organizada de la siguiente manera. En el Cap\'itulo~\ref{cap:preliminares.testing} daremos una introducci\'on a \emph{testing} como t\'ecnica para comprobar parcialmente el correcto funcionamiento de un programa, la automatizaci\'on de esta t\'ecnica, y una breve introducci\'on a criterios de cobertura. En el Cap\'itulo~\ref{cap:preliminares.mutation} presentaremos \emph{mutation testing}, como un criterio de testing. En este cap\'itulo mostraremos cu\'ales son las propiedades que afectan a la calidad de este criterio para evaluar un conjunto de tests, y algunos mecanismos para evaluar estas propiedades. La presentaci\'on y definici\'on de \emph{prvo} como un operador de mutaci\'on para expresiones de navegaci\'on se introducir\'a en el Cap\'itulo~\ref{cap:prvo}, as\'i como la descripci\'on de las fallas reales que est\'an relacionadas a este operador. En el Cap\'itulo~\ref{cap:implementation} se presenta una versi\'on implementada de \emph{prvo}, considerando restricciones a su definici\'on general provista en el cap\'itulo anterior, y teniendo en cuenta las propiedades que identificamos para el dise\~no de operadores de mutaci\'on. Describiremos tambi\'en la plataforma sobre la que \emph{prvo} es implementado, y las caracter\'isticas principales de la misma, principalmente el an\'alisis din\'amico de subsumci\'on de mutantes, el cual ser\'a parte de nuestra evaluaci\'on. La evaluaci\'on en el contexto de mutation testing, se realiza en el Cap\'itulo~\ref{cap:evaluation}. Introduciremos brevemente el \'area de reparaci\'on autom\'atica de programas en el Cap\'itulo~\ref{cap:repair}, en conjunto con una descripci\'on de la herramienta que utilizaremos para poner a prueba a \emph{prvo}, el operador de mutaci\'on introducido en esta tesis, en dicho contexto. Las conclusiones se presentan en el Cap\'itulo~\ref{cap:conclutions}, y trabajos futuros son descriptos en el Cap\'itulo~\ref{cap:futurework}.

