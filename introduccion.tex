%!TEX root = main.tex
\chapter{Introducci\'on}
\label{cap:introduccion}

En la actualidad, el software se encuentra en todos los aspectos de la vida diaria, y en general la expectativa del usuario es confiar en que el mismo simplemente funciona. Nadie espera que el autom\'ovil no arranque por un error en el software embebido que utiliza, o que el cajero autom\'atico de un banco no retorne billetes al realizar una extracci\'on v\'alida, o que el reloj del tel\'efono celular marque un horario incorrecto, etc. Sin embargo, son innumerables los ejemplos de errores de software, que causan comportamientos indebidos del mismo. Algunos de estos errores pueden ser catastr\'oficos. Algunos ejemplos son los siguientes. En 2015 se descubri\'o un bug en el modelo Boeing 787 Dreamliner que pod\'ia causar el apagado de todos los generadores el\'ectricos del avi\'on, si \'este permanec\'ia encendido por m\'as de 248 d\'ias. En los a\~nos 80, un error en el c\'odigo del controlador para la m\'aquina de terapia de radiaci\'on \emph{Therac-25}, caus\'o la muerte de varios pacientes al administrar cantidades excesivas de radiaci\'on beta. En 2018 un bug en WhatsApp causaba que la aplicaci\'on, y en muchos casos el dispositivo, dejara de responder, si se recib\'ia un mensaje en Unicode, conteniendo una secuencia que repet\'ia el caract\'er especial que especifica la direcci\'on de renderizado del texto.
%REF: BUG AVION: https://s3.amazonaws.com/public-inspection.federalregister.gov/2015-10066.pdf
%REF: THREAC-25, CITATION NEEDED?
%REF: BLACK DOT OF DEATH, CITATION NEEDED?

Claramente, suponer que el software simplemente funciona, es un error. Los errores en un programa pueden tener consecuencias que van desde una molestia menor al usuario, hasta la p\'erdida de vidas. Esto muestra la enorme relevancia del problema de garantizar la correcci\'on de un programa, es decir, la comprobaci\'on de que para todo escenario de uso, incluyendo las entradas directas e indirectas del software, el programa se comporta como se espera, o equivalentemetne arroja el resultado esperado. Uno de los enfoques tradicionales, y de mayor adopci\'on en la pr\'actica, para analizar la correcci\'on de un programa es el \emph{testing}, que consiste en evaluar el comportamiento del programa en cuesti\'on en un conjunto espec\'ifico de escenarios de ejecuci\'on. Dado que la comprobaci\'on exhaustiva de todos los escenarios de ejecuci\'on es en general inviable salvo para programas muy simples, en la pr\'actica s\'olo un subconjunto de estos escenarios puede ser evaluado. Cu\'antos y cu\'ales de todos los escenarios se seleccionan est\'a directamente relacionado con la confianza que brindar\'a el proceso de testing, en caso de no encontrar fallas, de que el software funciona correctamente.

% No va aca
%No solamente es necesario un conjunto de escenarios, el comportamiento esperado requiere ser definido, y la forma m\'as simple es usando un valor esperado, por ejemplo, esperar que llamar a un m\'etodo \texttt{helloWorld()} retorne la cadena \emph{"Hello World"}; un ejemplo m\'as complejo es que luego de ejecutar el m\'etodo \texttt{insert(3)} sobre una lista vac\'ia, llamar al m\'etodo \texttt{contains(3)} retorne verdadero. Otra forma de evaluar el comportamiento esperado es evaluando propiedades, como un orden ascendente de los elementos en una lista simplemente encadenada, antes y despu\'es de ejecutar cualquier m\'etodo sobre la misma. Lo que define el comportamiento esperado es lo que se conoce como \emph{Or\'aculo}.

% No va aca
%Podemos entonces definir a un test, como una serie de pasos conteniendo tres partes principales: \emph{Preparaci\'on}(Arrange), consiste en definir o construir el escenario sobre el que se va a evaluar un programa; \emph{Ejecuci\'on}(Act), donde se va a ejecutar el programa a evaluar; \emph{Evaluaci\'on}(Assert), donde se va a evaluar el resultado obtenido contra el esperado.

Un conjunto de tests (los escenarios de ejecuci\'on del software bajo an\'alisis) debe ser necesariamente finito, lo cual implica que en general no es posible en la pr\'actica evaluar exhaustivamente una pieza de software en todos los posibles escenarios de ejecuci\'on. M\'as a\'un, la ejecuci\'on del software en los escenarios elegidos debe insumir recursos razonables; esto por supuesto va a depender del contexto y los recursos disponibles, pero en l\'ineas general es esperable que la ejecuci\'on de los casos de tests sea \emph{eficiente}, especialmente aquellos que el desarrollador utiliza como apoyo constante a sus actividades de programaci\'on. 

%No va aca
%finalmente el \'exito en la execuci\'on de estos tests, es decir, que ninguno detecte una diferencia entre el resultado obtenido y el esperado, deber\'ia servir como control de calidad del software.

Dado que la finalidad de testing es evaluar un programa en un subconjunto de todos sus escenarios posibles, como forma aproximada de estimar (a trav\'es de una generalizaci\'on) su correcto comportamiento en el universo de todos los escenarios de ejecuci\'on, es necesario contar con un criterio para evaluar la calidad del conjunto elegido, es decir, evaluar cu\'an bien un conjunto de escenarios representa el universo de \'estos. Intuitivamente, un buen conjunto de casos de tests, o \emph{test suite}, es aquel que tiene una alta capacidad de detectar fallas: si existe un bug en el programa, alg\'un test en la suite es capaz de detectarlo. Sin embargo, esta intuici\'on, como criterio para evaluar cu\'an buena es una suite, es viable s\'olo si uno conoce de antemano los bugs del programa bajo an\'alisis. 
% No tiene sentido aca, y no se entiende
%La raz\'on de esto es que las fallas se definen en t\'erminos de su reparaci\'on, por ejemplo, \emph{falta incrementar la variable \texttt{i} al recorrer el arreglo}, no solo eso, sin\'o que se define en base a \emph{una} posible reparaci\'on, cuando en general, \'estas son infinitas. 
Resulta necesario entonces utilizar criterios indirectos, para medir la calidad de suites de tests. Estos criterios definen en general metas o requisitos a cubrir por los tests, a partir de los cuales se puede \emph{medir} cu\'antos son efectivamente cubiertos. Estos criterios de evaluaci\'on se suelen dividir en dos categor\'ias principales: \emph{caja blanca} (white box), cuando las metas a cubrir se basan en la estructura del programa, y \emph{caja negra} (black box), cuando las metas se basan en las especificaciones. Algunos ejemplos t\'ipicos de citerios de caja blanca son la \emph{cobertura de sentencias}, que exige ejecutar a trav\'es de la suite todas las sentencias en un programa, y \emph{cobertura de ramas}, que exige ejecutar todas las alternativas para las sentencias de control de flujo. Determinar clases de equivalencia para las entradas del programa basado en su especificaci\'on, y tener al menos un escenario por cada una de estas clases, es un ejemplo de un criterio de caja negra (denominado \emph{particionado en clases de equivalencia}).

Un ejemplo de como los criterios de evaluaci\'on de test suite intentan dar una medida indirecta de la capacidad del mismo en detectar fallas potenciales, se puede apreciar en la cobertura de sentencias, este criterio impone como metas a cubrir, la ejecuci\'on de cada una de las sentencias del programa bajo evaluaci\'on. La intuici\'on de este criterio es bastante simple, lo m\'inimo y necesario para descubrir una falla, es ejecutar la sentencia o sentencias en donde se encuentra el defecto asociado a la misma. Es sin embargo f\'acil de encontrar ejemplos de fallas simples, en donde este criterio da una evaluaci\'on positiva a un conjunto de tests, que es incapaz de detectar estos casos. Varios de estos ejemplos pueden ser detectados por un test suite que tenga una buena evaluaci\'on por parte del criterio de cobertura de ramas. Esto lleva a que evidentemente hay criterios que generan m\'as confianza que otros. Retomando la intuici\'on inicial de evaluar un test suite bajo su habilidad de detectar fallas, un criterio razonable y factible, es la de utilizar fallas artificiales, es decir, fallas conocidas, inyectadas en el programa, para evaluar si las mismas son detectadas por el conjunto de tests bajo evaluaci\'on. Esto sigue el razonamiento de que los programadores suelen crear programas, que cuando tienen fallas, el programa no est\'a lejos de la soluci\'on correcta \cite{bibliography.mutation.DeMillo}, y por lo tanto, peque\~nos cambios sint\'acticos en un programa deber\'ian emular los errores que se suelen cometer en su desarrollo.

\emph{Mutation testing}, es un criterio que genera copias del programa original, en donde cada una tiene inyectada una falla artificial, \emph{mutante}, en forma de un cambio sint\'actico simple, \emph{mutaci\'on}. Por cada mutante se ejecutan los tests, si al menos uno de estos falla, entonces se marca al mutante como detectado. El valor asociado a este criterio, \emph{mutation score}, es la relaci\'on entre mutantes detectados y todos los generados. Las fallas artificiales generadas por mutation testing, est\'an basadas en distintos operadores de mutaci\'on que definen familias de cambios sint\'acticos similares. Por ejemplo, dada una expresi\'on relacional binaria, cambiar el operador de relaci\'on por cada uno de los existentes en el lenguaje en el cual el programa est\'a desarrollado, es un operador de mutaci\'on. Numerosos estudios han intentado responder si existe una correlaci\'on (acoplamiento) entre la capacidad de un test suite en detectar fallas artificiales, utilizadas en mutation testing, y la capacidad de hacerlo para fallas reales, entre ellos, \cite{bibliography.mutation.evaluation.coupling.Offutt89, bibliography.mutation.evaluation.coupling.Offutt92, bibliography.mutation.evaluation.HAndrews05, bibliography.mutation.evaluation.valid-substitute}. Estos estudios han encontrado que de hecho existe una correlaci\'on, aunque siempre acotada a casos de estudio particulares. A\'un teniendo en cuenta estos resultados, el rendimiento del criterio est\'a directamente relacionado a los operadores de mutaci\'on utilizados, y las fallas artificiales que estos generan. Por un lado, la cantidad de mutantes impacta en los recursos necesarios para ejecutar el an\'alisis, ya que en el peor caso es necesario ejecutar todos los tests para cada uno de los mutantes. Por el otro lado, existen fallas artificiales que son trivialmente detectables, por ejemplo, modificar el \'indice en el acceso a un arreglo a un valor negativo; y aquellas que son equivalentes al programa original, por ejemplo, incrementar una variable local en la sentencia de retorno de un m\'etodo. En el primer caso, ejecutar la sentencia va a causar un error, y cualquier test que lo haga va a detectar dicho mutante, este tipo de fallas triviales van a aumentar el mutation score sin realmente significar un aumento en la calidad del test suite. En el segundo caso, no existe ning\'un escenario para el cual el comportamiento del mutante difiera del comportamiento observable del programa original, en este caso, el valor del mutation score va a decrementar sin significar un empeoramiento en el test suite. Finalmente, as\'i como las fallas artificiales pueden estar acopladas a fallas reales, el mismo fen\'omeno puede ocurrir entre los mutantes, es decir, detectar ciertos mutantes va a implicar que otros sean tambi\'en detectados. Este caso de acoplamiento entre mutantes, lleva a un aumento del mutation score, que si bien puede estar asociado a fallas artificiales no triviales, \'estas, son similares, y no implican que el test suite sea capaz de detectar mayor variedad de fallas reales.

Existen varios estudios que intentan atacar los problemas mencionados anteriormente, desde aquellos que lo hacen seleccionando un conjunto \emph{suficiente} de operadores de mutaci\'on \cite{bibliography.mutation.selection.Offutt96, bibliography.mutation.selection.ASN2008}; buscando m\'etodos para detectar mutantes equivalentes, \cite{biblography.mutation.evaluation.equivalent.Grun+09, biblography.mutation.evaluation.equivalent.Schuler+10, biblography.mutation.evaluation.equivalent.Just+13}; y utilizando una combinaci\'on de mutaciones, para generar mutantes sut\'iles bajo el razonamiento de que \'estos deber\'ian representar fallas m\'as dif\'iciles de detectar, \cite{bibliography.mutation.highorder.Jia+08, bibliography.mutation.highorder.Jia+09, bibliography.mutation.highorder.Harman+11}. Un resultado de especial inter\'es es el de Just et Al. \cite{bibliography.mutation.evaluation.valid-substitute}, que una de sus conclusiones es que existen fallas reales que requieren mejorar operadores de mutaci\'on existentes, o desarrollar operadores nuevos, exponiendo la necesidad de mejorar operadores de mutaci\'on o desarrollar nuevos operadores, para poder representar a estos tipos de fallas reales no representadas actualmente.

\section{Motivaci\'on y Objetivos}
\label{sec:intro.objetivos}


\begin{figure}[t]
	\begin{lstlisting}[frame=tlrb, mathescape=true]
    public class Queue {
	
      private Node front;
      private Node last;
	
      ...
      public void dequeue() {
        this.front = this.front.next;
      }
	
      public int size() {
        // computes number of nodes in the 
        // underlying list
        ...
      }
      ...
    }
	\end{lstlisting}
	\caption{Una implementaci\'on de colas basada en referencias.}
	\label{figures.motivation.queue-class}
\end{figure}

En la actualidad, los lenguajes orientados a objetos, o que contienen caracter\'isticas similares, tienen una presencia mayoritaria dentro de los lenguajes utilizados. Un tipo de expresi\'on com\'unmente encontrado en este tipo de lenguajes, son las expresiones de navegaci\'on. \'Estas, se forman al acceder a miembros de clases (campos y m\'etodos) mediante un operador de acceso que suele seguir la notaci\'on punto. Incluso con la popularidad de estos lenguajes, ning\'un operador actual, ni siquiera aquellos que pertenecen al grupo de \emph{operadores suficientes}, generan mutaciones para este tipo de expresiones. La necesidad de agregar operadores que generen mutaciones para \'estas, se puede ver con un ejemplo muy simple.

Dada una implementaci\'on (defectuosa) de una cola sobre una lista simplemente encadenada, con una referencia al primer nodo, \emph{front}, y otra al \'ultimo, \emph{last}, y un m\'etodo \emph{dequeue()}, tal como se muestra en la Figura-\ref{figures.motivation.queue-class}. Cualquier test que haga una llamada a este m\'etodo va a lograr una cobertura estructural (ramas por ejemplo) del 100\%.
%HERE===========
Ninguna de las herramientas actuales de mutation testing, por ejemplo, \emph{PITest}, \emph{Major}, ni \emph{$\mu$Java}, generan mutaciones para el c\'odigo en \emph{dequeue()}, haciendo que sea trivial para cualquiera de estos tests de lograr una cobertura de mutaci\'on. Por lo tanto, tener un \'unico test para este m\'etodo, como el siguiente:
\begin{center}
	\begin{lstlisting}[frame=tlrb, mathescape=true]
    @Test
    public void dequeueTest() {
      Queue q = new Queue();
      q.push(1);
      int size = q.size();
      q.dequeue();
      assertEquals(size - 1, q.size());
    }
	\end{lstlisting}
\end{center}
va a ser suficiente para lograr una cobertura (ramas) del 100\%, y cubrir de manera trivial todos los objetivos definidos por mutation testing.

El problema en este caso es que, dentro de mutation testing, ning\'un operador de mutaci\'on es capaz de mutar el cuerpo de \emph{dequeue()}, por lo tanto, este criterio falla en imponer cualquier requisito (metas de cobertura) a la test suite. Si las expresiones de este tipo fueran raramente encontradas en programas actuales, podr\'iamos simplemente considerar a \'este, un problema poco importante e ignorarlo. Pero las expresiones de navegaci\'on, del estilo de las que constituyen el cuerpo de \emph{dequeue()}, son muy comunes en programas que utilizan lenguajes orientados a objetos. Es m\'as, algunos patrones de dise\~no, exclusivos a lenguajes orientados a objetos, como \emph{Builder}, o \emph{Fluent Interfaces}, hacen uso substancial de expresiones de navegaci\'on.

El patr\'on \emph{Builder} es utilizado para construir instancias de objetos que suelen contener una gran cantidad de atributos opcionales, sin la necesidad de una gran cantidad de distintos constructores. No solo eso, sin\'o tambi\'en permitir que la construcci\'on de un objeto complejo sea f\'acil de leer en el c\'odigo. Un ejemplo de una librer\'ia que utiliza este patr\'on es \emph{Apache Commons CLI}, una librer\'ia para manejar los argumentos de entrada de una aplicaci\'on de terminal. Un ejemplo del uso de \'esta se muestra a continuaci\'on:
\begin{center}
	\begin{lstlisting}[mathescape=true]
    Option inputOption = Option.builder("V")
      .longOpt("Value")
      .desc("The input value")
      .hasArg(true)
      .numberOfArgs(1)
      .type(Integer.class)
      .required(true)
      .build();
	\end{lstlisting}
\end{center}
En donde se muestra la creaci\'on de un argumento para un programa que utiliza \emph{-V} o \emph{--Value} para hacer referencia al argumento, define una descripci\'on del mismo (\emph{The input value}), especifica que el argumento requiere un \'unico valor asociado de tipo entero y que el argumento es obligatorio. Un ejemplo de uso de esa opci\'on ser\'ia:
\begin{lstlisting}
  miPrograma --Value 42
\end{lstlisting}

\emph{Fluent Interfaces}, o interfaces fluentes, hace referencia a programas en donde se utiliza la jerarqu\'ia de clases, asociada a los lenguajes orientados a objetos, para determinar una gram\'atica que permite definir un lenguaje de dominio espec\'ifico. Como por ejemplo una librer\'ia de SQL en Java:
\begin{center}
	\begin{lstlisting}[mathescape=true]
	dbconnector.from("Songs").select().where()
	.attribute("year").ge().value(1980)
	.and()
	.attribute("year").lt().value(1990)
	.ejecute()
	\end{lstlisting}
\end{center}
En donde se muestra el uso de \emph{method chaining} para escribir una consulta a la tabla \emph{Songs} de la cual se van a seleccionar aquellas entradas en donde el atributo \emph{year} sea mayor o igual a 1980 y menor que 1990.

Un punto importante a notar en el ejemplo anterior, es que si bien existen operadores relacionales que pueden modificar un ``mayor o igual a'' por otro operador, el caso de \texttt{attribute(``year'').ge().value(1980)}, es sem\'anticamente equivalente a \texttt{attribute(``year'') >= 1980} pero no puede ser mutado.

El conjunto de \emph{operadores suficientes} de mutaci\'on, ha permanecido pr\'acticamente inalterado desde hace a\~nos, si bien el primer trabajo que ofrece un conjunto de operadores formalmente definidos, lo hace para el lenguaje FORTRAN \cite{bibliography.mutation.definitions.fortranOffut87, bibliography.mutation.definitions.fortranKing91}, mutation testing fue siendo aplicado y evaluado en varios lenguajes, incluyendo aquellos considerados orientados a objetos como ADA y JAVA, por dar un ejemplo. Sin embargo los operadores de mutaci\'on espec\'ificos para lenguajes orientados a objetos solo afectan, en general, jerarqu\'ia de clases, visibilidad, y sobre-escritura. 

Esto nos lleva a nuestros objetivos:

\begin{enumerate}[leftmargin=.75cm,align=left,style=nextline]
	\item[\textbf{Determinar las propiedades que un operador deber\'ia satisfacer}]\mbox{}\\ Dise\~nar un operador de mutaci\'on no es una tarea trivial, tal como mencionamos anteriormente, mutantes equivalentes al programa original son indeseados, as\'i como aquellos que son trivialmente detectados; los mutantes generados deben representar, estar acoplados a, fallas reales. De esta manera, nuestro primer objetivo es, definir estas propiedades, de manera precisa y definiendo metodolog\'ias para evaluar a las mismas.
	
	\item[\textbf{Definir un operador de mutaci\'on para expresiones de navegaci\'on}]\mbox{}\\
	Teniendo en cuenta las propiedades definidas anteriormente, y la motivaci\'on para dise\~nar nuevo[s] operadores de mutaci\'on para expresiones de navegaci\'on, nuestro segundo objetivo, es dar una definici\'on de un nuevo operador que satisfaga estas necesidades. Esta definici\'on debe ser agn\'ostica al lenguaje de programaci\'on utilizado para implementarlo.
	
	\item[\textbf{Implementar el operador de mutaci\'on para expresiones de navegaci\'on}] Los operadores existentes actualmente est\'an definidos por reglas de transformaci\'on muy simples, incluso siendo capaz de ser implementados usando expresiones regulares. Modificar una expresi\'on de navegaci\'on requiere informaci\'on de tipos y an\'alisis de alcanzabilidad para determinar las expresiones disponibles al modificar una existente. Nuestro tercer objetivo entonces, es encontrar una herramienta de mutaci\'on que permita realizar el an\'alis necesario para generar estas mutaciones; elegir un lenguaje sobre el cual y para el cual implementar este operador; e implementar tanto el operador como herramientas u extensiones que permitan realizar los an\'alisis apropiados para las evaluaciones necesarias a nuestro operador.
	
	\item[\textbf{Evaluaci\'on}]\mbox{}\\
	Incluso si es cierto que existe una necesidad por la generaci\'on de mutantes para expresiones de navegaci\'on, si el o los operadores que los generan, no cumplen con las propiedades anteriormente descriptas, entonces su utilidad se ve muy reducida. Por eso, nuestro objetivo final, es evaluar el desempe\~no de nuestro operador para demostrar su utilidad, con respecto a las propiedades definidas por el primer objetivo.
\end{enumerate}

%Objetivos

\section{Contribuciones}
\label{sec:intro.contribuciones}

%Se pueden mencionar papers publicados

La definici\'on e implementaci\'on de un operador de mutaci\'on, altamente configurable, para expresiones de navegaci\'on, dentro del contexto de mutation testing, es la principal contribuci\'on de este trabajo. Dado que la mutaci\'on de expresiones de navegaci\'on generar\'ia en principio una cantidad inmanejable de mutantes, es necesario encontrar y definir el tipo de fallas que se desean generar. Incluso si la generaci\'on de mutantes para expresiones de navegaci\'on representa un conjunto de fallas no representadas actualmente, no alcanza con generar a las mismas, sino tambi\'en es necesario evaluar que el rendimiento de mutation testing no se vea significativamente afectado de forma negativa al agregar estas mutaciones. Espec\'ificamente en esta tesis presentaremos las siguientes contribuciones principales:

\begin{enumerate}
	\item Dar una definici\'on formal de un operador para expresiones de navegaci\'on. Si bien la implementaci\'on que se ofrece en esta tesis es implementada en una herramienta espec\'ifica, y para un lenguaje particular, la definici\'on del operador deber\'ia permitir su implementaci\'on en cualquier herramienta y lenguaje. Una de las razones para esto incluye su utilizaci\'on para lenguajes de modelado, como Alloy \cite{bibliography.books.SoftwareAbstractions-alloy}, basados en trabajos como \cite{bibliography.repair.mutation.AlloyWang18}, que propone una herramienta de reparaci\'on de modelos escritos en este lenguaje, y \cite{bibliography.algebraicExpressions.RexGenWang18}, que expone la necesidad de la generaci\'on autom\'atica de expresiones en \'algebra relacional para distintos campos, entre ellos, reparaci\'on autom\'atica y ayudas al desarrollador (tooltips autom\'aticos).
	
	\item Implementar un operador para expresiones de navegaci\'on. Nuestra implementaci\'on est\'a enfocada al lenguaje \emph{Java}, dado que es un buen representante de lenguajes orientados a objetos. Nuestra implementaci\'on est\'a realizada en una versi\'on modificada de \emph{$\mu$Java} \cite{bibliography.mutation.tools.muJavaMaOK05}, llamada \emph{$\mu$Java++}, que nos permite realizar an\'alisis de tipos y alcanzabilidad que otras herramientas no permiten. Aprovecharemos para implementar distintos an\'alisis que usaremos durante la evaluaci\'on, como \emph{dureza}(toughness), que mide cuantos tests fue capaz de sobrevivir un mutante antes de ser detectado, este valor puede ser tomado como un indicador de cuan dif\'icil es detectar un mutante, y permitir\'ia sacar conclusiones sobre la dificultad de los mutantes generados por un operador; \emph{subsumci\'on}(subsumption) de mutantes, es un an\'alis que permite poner en evidencia para un programa particular, con un conjunto de tests particular, mutantes redundantes. Como veremos m\'as adelante, generar mutaciones para expresiones de navegaci\'on, requiere una gran cantidad de ``fine tuning'', para maximizar las fallas reales representadas, minimizando caracter\'isticas no deseadas, entre ellas, una gran cantidad de mutantes. Por esto, nuestro operador termina siendo definido como un ``meta-operador'' el cual, mediante una amplia gama de configuraciones, puede verse como una familia de operadores, donde cada operador es una configuraci\'on particular.
\end{enumerate}

Evaluaremos nuestro operador bajo las siguientes colecciones implementadas y utilizando caracter\'isticas de programaci\'on orientada a objetos: \emph{TreeList}, una implementaci\'on de listas basada en \'arboles; \emph{NodeCachingList}, una lista encadenada con una cache de nodos; \emph{AvlTree}, una implementaci\'on cl\'asica de \'arboles balanceados; \emph{BinomialHeap}, una implementaci\'on de mont\'iculos basada en referencias; \emph{TreeSet}, una implementaci\'on de conjuntos basada en \'arboles rojos y negros; y \emph{BSTree}, una implementaci\'on de \'arboles binarios de b\'usqueda. Los experimentos fueron corridos en computadoras utilizando Intel Core i7 7700HQ CPUs a 2.8GHz, 16Gb de RAM, corriendo bajo GNU/Linux. Contrastaremos el efecto de agregar este operador al conjunto suficiente de operadores definidos en la literatura y que se encuentran implementados en \emph{$mu$Java++}. Es necesario considerar que nuestra versi\'on de esta herramienta contiene numerosas mejoras a los operadores ya existentes en la versi\'on original, \emph{$\mu$Java}, principalmente validaciones faltantes para evitar la generaci\'on de mutantes que no compilan (un subconjunto de los mutantes triviales), como por ejemplo no agregar el operador \texttt{++} a una expresi\'on constante.

A su vez, mostraremos el uso de \emph{prvo} en el contexto de reparaci\'on autom\'atica de programas, y como ciertas fallas solo pueden ser reparadas al considerar al mismo.

\section{Organizaci\'on}
\label{sec:intro.organizacion}

En \ref{cap:preliminares.testing} daremos una introducci\'on a \emph{testing} como t\'ecnica para evaluar un programa con respecto a su correcto funcionamiento, la automatizaci\'on de este t\'ecnica, y una breve introducci\'on a criterios de cobertura. En \ref{cap:preliminares.mutation} presentaremos \emph{mutation testing}, como un criterio de cobertura, en este capitulo mostraremos cuales son las propiedades que afectan a la calidad de este criterio para evaluar un conjunto de tests, y algunos mecanismos para evaluar a estas propiedades. Reparaci\'on autom\'atica de programas ser\'a brevemente introducido en \ref{cap:preliminares.repair} en conjunto a una descripci\'on de la herramienta que utilizaremos para poner a prueba a \emph{prvo} en dicho contexto. La presentaci\'on y definici\'on de \emph{prvo} como un operador de mutaci\'on para expresiones de navegaci\'on se hace en \ref{cap:prvo}, as\'i como la descripci\'on de que fallas reales est\'an relacionadas a nuestro operador. En \ref{cap:implementation} se presenta a \emph{prvo} considerando restricciones a su definici\'on general provista en el capitulo anterior, teniendo en cuenta las propiedades que el dise\~no de un operador de mutaci\'on deber\'ia considerar, a su vez se describe nuestra plataforma sobre la que \emph{prvo} es implementado, y las caracter\'isticas principales de la misma, principalmente el an\'alisis din\'amico de subsuma de mutantes, el cual va a ser una gran parte de nuestra evaluaci\'on. La evaluaci\'on en el contexto de mutation testing, se realiza en 
\ref{cap:evaluation}, con las conclusiones en \ref{cap:conclutions} y trabajos a futuro descriptos en \ref{cap:futurework}.

