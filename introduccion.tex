%!TEX root = main.tex
\chapter{Introducci\'on}
\label{cap:introduccion}
En la actualidad, el software se encuentra en todos los aspectos de la vida diaria, y en general la expectativa del usuario es confiar en que el mismo simplemente funciona. Nadie espera que el auto no arranque por un error en el software embebido que utiliza, el cajero de un banco no retorne billetes al realizar una extracci\'on v\'alida, que el reloj del celular marque un horario incorrecto, etc. Sin embargo, para nombrar algunos ejemplos de que esto no sucede, en 2015, se descubri\'o un bug en el modelo Boing 787 Dreamliner que pod\'ia causar el apagado de todos los generadores el\'ectricos del avi\'on si \'este permanec\'ia encendido por m\'as de 248 d\'ias; En los 80, un error en el c\'odigo del controlador para la m\'aquina de terapia de radiaci\'on, \emph{Therac-25} caus\'o la muerte de varios pacientes al administrar cantidades excesivas de radiaci\'on beta; En 2018 un bug en WhatsApp causaba que la aplicaci\'on, y en muchos casos, el dispositivo, dejara de responder, si se recib\'ia un mensaje en Unicode conteniendo una secuencia que repet\'ia el caract\'er especial que especif\'ica la direcci\'on del texto.
%REF: BUG AVION: https://s3.amazonaws.com/public-inspection.federalregister.gov/2015-10066.pdf
%REF: THREAC-25, CITATION NEEDED?
%REF: BLACK DOT OF DEATH, CITATION NEEDED?
Claramente, asumir que el software simplemente funciona, no es posible. Los errores en un programa pueden tener consecuencias que van desde una molestia menor al usuario, hasta la perdida de vidas. Esto evidencia un problema a resolver, evaluar la correctitud de un programa, es decir, si para todo escenario de uso, el cual incluye entradas directas e indirectas, el programa da el resultado esperado. \'Esto es en general inviable salvo para programas triviales, por lo que solo un subconjunto de estos escenarios puede ser evaluado. Cuantos y cuales de todos los escenarios se seleccionan est\'a directamente relacionado con la confianza de que, en caso de no encontrar fallas, el software sea correcto.

No solamente es necesario un conjunto de escenarios, el comportamiento esperado requiere ser definido, y la forma m\'as simple es usando un valor esperado, por ejemplo, esperar que llamar a un m\'etodo \texttt{helloWorld()} retorne la cadena \emph{"Hello World"}; un ejemplo m\'as complejo es que luego de ejecutar el m\'etodo \texttt{insert(3)} sobre una lista vac\'ia, llamar al m\'etodo \texttt{contains(3)} retorne verdadero. Otra forma de evaluar el comportamiento esperado es evaluando propiedades como que para una lista simplemente encadenada, luego de ejecutar un m\'etodo particular, la misma est\'e ordenada. Lo que define el comportamiento esperado es lo que se conoce como \emph{Or\'aculo}.

Podemos entonces definir a un test como una serie de pasos conteniendo tres partes principales: \emph{Preparaci\'on}(Arrange), consiste en definir o construir el escenario sobre el que se va a evaluar un programa; \emph{Ejecuci\'on}(Act), donde se va a ejecutar el programa a evaluar; \emph{Evaluaci\'on}(Assert), donde se va a evaluar el resultado obtenido contra el esperado.

Un conjunto de tests debe entonces, ser finito, por que no es posible utilizar todos los escenarios posibles; su ejecuci\'on debe requerir recursos razonables, donde estos van a depender del contexto y los recursos disponibles, aunque en general es esperable que al menos haya un conjunto de tests que puedan ser ejecutados de manera r\'apida como apoyo al desarrollador; finalmente el \'exito en la execuci\'on de estos tests, es decir que ninguno detecte una diferencia entre el resultado obtenido y el esperado, deber\'ia servir como control de calidad del software.

Es necesario contar con un criterio para evaluar la calidad de un conjunto de tests. Dado que al ser finito, la confianza que genera en la correctitud de un programa va a depender de cuales tests fueron elegidos. Intuitivamente, evaluar que tan bueno es un test suite detectando fallas parece ser un buen criterio, sin embargo, salvo para fallas conocidas, no es posible realizar esta evaluaci\'on. La raz\'on de esto es que las fallas se definen en t\'erminos de su reparaci\'on, por ejemplo, \emph{falta incrementar la variable \texttt{i} al recorrer el arreglo}, no solo eso, sin\'o que se define en base a \emph{una} posible reparaci\'on, cuando en general, \'estas son infinitas. Criterios indirectos son entonces necesarios, \'estos definen metas a cubrir por los tests y eval\'uan cuantas son finalmente cubiertas. Estos criterios de cobertura se suelen dividir en dos categor\'ias principales: \emph{Caja blanca}(White box), cuando las metas a cubrir se basan en la estructura del programa; \emph{Caja negra}(Black box), cuando las metas se basan en las especificaciones. Ejecutar todas las sentencias en un programa, \emph{Cobertura de sentencias}, y, ejecutar todas las alternativas para las sentencias de control de flujo, \emph{Cobertura de ramas}, son ejemplos de caja blanca; determinar clases de equivalencia para las entradas del programa basado en su especificaci\'on y tener al menos un escenario por cada una de estas clases es un ejemplo de caja negra.

Un ejemplo de como los criterios de evaluaci\'on de test suite intentan dar una medida indirecta de la capacidad del mismo en detectar fallas potenciales, se puede apreciar en la cobertura de sentencias, este criterio impone como metas a cubrir, la ejecuci\'on de cada una de las sentencias del programa bajo evaluaci\'on. La intuici\'on del este criterio es bastante simple, lo m\'inimo y necesario para descubrir una falla, es ejecutar la sentencia o sentencias en donde se encuentra. Es sin embargo f\'acil de encontrar ejemplos de fallas simples en donde este criterio da una evaluaci\'on positiva a un conjunto de tests que es incapaz de detectar estos casos. Varios de estos ejemplos pueden ser detectados por un test suite que tenga una buena evaluaci\'on de parte del criterio de cobertura de ramas. Esto lleva a que evidentemente hay criterios que generan m\'as confianza que otros. Retomando la intuici\'on inicial de evaluar un test suite bajo su habilidad de detectar fallas, un criterio razonable y factible, es la de utilizar fallas artificiales, es decir, fallas conocidas, inyectadas en el programa para evaluar si las mismas son detectadas por el conjunto de test bajo evaluaci\'on. Esto sigue el razonamiento de que los programadores suelen crear programas que cuando tienen fallas, el programa no est\'a lejos de la soluci\'on correcta \cite{bibliography.mutation.DeMillo}, y por lo tanto, peque\~nos cambios sint\'acticos en un programa deber\'ian emular los errores que se suelen cometer en su desarrollo.

\emph{Mutation testing}, es un criterio que genera copias del programa original en donde cada uno tiene inyectada una falla artificial, \emph{mutante}, en forma de un cambio sint\'actico simple, \emph{mutaci\'on}. Por cada mutante se ejecutan los tests, si al menos uno de estos falla, entonces se marca al mutante como detectado. El valor asociado a este criterio es la relaci\'on entre mutantes detectados y todos los mutantes, \emph{mutation score}. Las fallas artificiales generadas por mutation testing est\'an basadas en distintos operadores de mutaci\'on que definen familias de cambios sint\'acticos similares. Por ejemplo, dada una expresi\'on relacional binaria, cambiar el operador de relaci\'on por cada uno de los existentes en el lenguaje en el cual el programa est\'a desarrollado, es un operador de mutaci\'on. Numerosos estudios han intentado responder si existe una correlaci\'on (acoplamiento) entre la capacidad de un test suite en detectar fallas artificiales utilizadas en mutation testing y la capacidad de hacerlo para fallas reales, entre ellos, \cite{bibliography.mutation.evaluation.coupling.Offutt89, bibliography.mutation.evaluation.coupling.Offutt92, bibliography.mutation.evaluation.HAndrews05, bibliography.mutation.evaluation.valid-substitute}, estos estudios han encontrado que de hecho existe una correlaci\'on, aunque siempre acotada a casos de estudio particulares. A\'un teniendo en cuenta estos resultados, el rendimiento del criterio est\'a directamente relacionado a los operadores de mutaci\'on utilizados y las fallas artificiales que estos generan. Por un lado la cantidad de mutantes impacta en los recursos necesarios para ejecutar el an\'alisis, ya que en el peor caso es necesario ejecutar todos los tests para cada uno de los mutantes. Por el otro lado, existen fallas artificiales que son trivialmente detectables, por ejemplo, modificar el \'indice en el acceso a un arreglo a un valor negativo, y aquellas que son equivalente al programa original. En el primer caso, ejecutar la sentencia va a causar un error, y cualquier test que lo haga va a detectar dicho mutante, este tipo de fallas triviales van a aumentar el mutation score sin realmente significar un aumento en la calidad del test suite. En el segundo caso, no existe ning\'un escenario para el cual el comportamiento del mutante difiera del comportamiento observable del programa original, en este caso el valor del mutation score va a decrementar sin significar un empeoramiento en el test suite. Finalmente as\'i como las fallas artificiales pueden estar acopladas a fallas reales, el mismo fen\'omeno puede ocurrir entre los mutantes, es decir, detectar ciertos mutantes va a implicar que otros sean tambi\'en detectados. Este caso de acoplamiento entre mutantes lleva a un aumento del mutation score que si bien puede estar asociado a fallas artificiales no triviales, son fallas similares que no implican que el test suite sea capaz de detectar mayor variedad de fallas reales.

Existen varios estudios que intentan atacar los problemas mencionados anteriormente, desde aquellos que lo hacen seleccionando un conjunto \emph{suficiente} de operadores de mutaci\'on \cite{bibliography.mutation.selection.Offutt96, bibliography.mutation.selection.ASN2008}; buscando m\'etodos para detectar mutantes equivalentes, \cite{biblography.mutation.evaluation.equivalent.Grun+09, biblography.mutation.evaluation.equivalent.Schuler+10, biblography.mutation.evaluation.equivalent.Schuler+13, biblography.mutation.evaluation.equivalent.Just+13}; y utilizando una combinaci\'on de mutaciones para generar mutantes sut\'iles bajo el razonamiento de que \'estos deber\'ian representar fallas m\'as dif\'iciles de detectar, \cite{bibliography.mutation.highorder.Jia+08, bibliography.mutation.highorder.Jia+09, bibliography.mutation.highorder.Harman+11}. Un resultado de especial inter\'es es el de Just et Al. \cite{bibliography.mutation.evaluation.valid-substitute} que una de sus conclusiones es que existen fallas reales que requieren mejorar operadores de mutaci\'on existentes, o desarrollar operadores nuevos.

%Metodológicamente, explicar en qué consiste tener una etapa de captura y especificación de requisitos concreta en el proceso de desarrollo.

%Etapa de análisis = captura y especificación de requisitos. Con qué contamos para hacerlo.Y captura? Varias herramientas vinculadas al “proceso”. Ej.: checklists, listas de preguntas frecuentes sobre el software a construir, etc. 

%Con qué contamos para hacerlo. Lenguaje natural, lenguajes de propósito específico (todo esto es especificación).
%Algunas herramientas metodológicas: Diagramas de estímulo/respuesta, DFDs y descomposición de funcionalidades, 4-variable model, KAOS. 

%natural 

%informales 

%Lenguaje natural vs. lenguajes formales para la especificación de requisitos. Sintaxis formal vs sintaxis+semántica. Posibilidades de análisis “objetivo” de specs, libre de interpretaciones subjetivas de las specs por parte de los ingenieros . Algunos antecedentes (mencionados superficialmente).

%Sintaxis + semántica formales facilitan análisis (semi-)automático vinculado a specs de requisitos. Qué se puede sistematizar? (algunos ejemplos de tareas).  Automático vs. asistido. Ejemplos de alto nivel, y mencionando sólo referencias, no trabajos concretos.
%Algunos ejemplos de trabajos explotando estas observaciones: referencias, descripciones superficiales.

%semi-automaticas 

%automaticas

% % % %


\section{Motivaci\'on y Objetivos}
\label{sec:intro.objetivos}
% RE etapa mas informal del proceso de desarrollo
% incertidumbre, desconocimiento, parcialidad.
%[operacional vs declarativo]

\begin{figure}[t]
	\begin{lstlisting}[frame=tlrb, mathescape=true]
    public class Queue {
	
      private Node front;
      private Node last;
	
      ...
      public void dequeue() {
        this.front = this.front.next;
      }
	
      public int size() {
        // computes number of nodes in the 
        // underlying list
        ...
      }
      ...
    }
	\end{lstlisting}
	\caption{Una implementaci\'on de colas basada en referencias.}
	\label{figures.motivation.queue-class}
\end{figure}

En la actualidad, los lenguajes orientados a objetos, o que contienen caracter\'isticas similares, tienen una presencia mayoritaria dentro de los lenguajes utilizados. Un tipo de expresi\'on com\'unmente encontrado en este tipo de lenguajes, son las expresiones de navegaci\'on. \'Estas se forman al acceder a miembros de instancias de clases mediante un operador de acceso que suele seguir la notaci\'on punto. Incluso con la popularidad de estos lenguajes, ning\'un operador actual, ni siquiera aquellos que pertenecen al grupo de \emph{operadores suficientes}, generan mutaciones para este tipo de expresiones. La necesidad de agregar operadores que generen mutaciones para \'estas, se puede ver con un ejemplo muy simple.

Dada una implementaci\'on (defectuosa) de una cola sobre cadenas simplemente encadenadas, con una referencia al \emph{primer} nodo y otra al \emph{\'ultimo}, y un m\'etodo \emph{dequeue()} tal como se muestra en la Figura-\ref{figures.motivation.queue-class}. Cualquier test que haga una llamada a este m\'etodo va a lograr una cobertura estructural (ramas por ejemplo) del 100\%.
%HERE===========
Ninguna de las herramientas actuales de mutation testing, por ejemplo, \emph{PITest}, \emph{Major}, ni \emph{$\mu$Java}, generan mutaciones para el c\'odigo en \emph{dequeue()} haciendo que sea trivial para cualquiera de estos tests de lograr una cobertura de mutaci\'on. Por lo tanto, tener un \'unico test para este m\'etodo, como el siguiente:
\begin{center}
	\begin{lstlisting}[frame=tlrb, mathescape=true]
    @Test
    public void dequeueTest() {
      Queue q = new Queue();
      q.push(1);
      int size = q.size();
      q.dequeue();
      assertEquals(size - 1, q.size());
    }
	\end{lstlisting}
\end{center}
va a ser suficiente para lograr una cobertura (ramas) del 100\%, y cubrir de manera trivial todos los objetivos definidos por mutation testing.

El problema en este caso es que, dentro de mutation testing, ning\'un operador de mutaci\'on es capaz de mutar el cuerpo de \emph{dequeue()}, por lo tanto este criterio falla en imponer cualquier restricci\'on (metas de cobertura) a la test suite. Si las expresiones de este tipo fueran raramente encontradas en programas actuales, podr\'iamos simplemente considerar este problema como poco importante e ignorarlo. Pero las expresiones de navegaci\'on, del estilo de las que constituyen el cuerpo de \emph{dequeue()}, son muy comunes en programas que utilizan lenguajes orientados a objetos. Es m\'as, algunos patrones de disen\~no exclusivos a lenguajes orientados a objetos, como \emph{Builder}, o \emph{Fluent Interfaces}, hacen uso substancial de expresiones de navegaci\'on.

El patr\'on \emph{Builder} es utilizado para construir instancias de objetos que suelen contener una gran cantidad de atributos opcionales sin la necesidad de una gran cantidad de distintos constructores. No solo eso, sin\'o tambi\'en, permitir que la construcci\'on de un objeto complejo sea f\'acil de leer en el c\'odigo. Un ejemplo de una librer\'ia que utiliza este patr\'on es \emph{Apache Commons CLI}, una librer\'ia para manejar los argumentos de entrada de una aplicaci\'on de terminal. Un ejemplo de el uso de \'esta se muestra a continuaci\'on:
\begin{center}
	\begin{lstlisting}[mathescape=true]
    Option inputOption = Option.builder("V")
      .longOpt("Value")
      .desc("The input value")
      .hasArg(true)
      .numberOfArgs(1)
      .type(Integer.class)
      .required(true)
      .build();
	\end{lstlisting}
\end{center}
En donde se muestra la creaci\'on de un argumento para un programa que utiliza \emph{-V} o \emph{--Value} para hacer referencia al argumento, define una descripci\'on del mismo (\emph{The input value}), especifica que el argumento requiere un \'unico valor asociado de tipo entero y que el argumento es requerido. Un ejemplo de uso de esa opci\'on ser\'ia \lstinline|miPrograma --Value 42|.

\emph{Fluent Interfaces}, o interfaces fluentes, hace referencia a programas en donde se utiliza la jerarqu\'ia de clases, asociadas a los lenguajes orientados a objetos, para determinar una gram\'atica que permite definir un lenguaje de dominio espec\'ifico. Como por ejemplo una librer\'ia de SQL en Java:
\begin{center}
	\begin{lstlisting}[mathescape=true]
	dbconnector.from("Songs").select().where()
	.attribute("year").ge().value(1980)
	.and()
	.attribute("year").lt().value(1990)
	.ejecute()
	\end{lstlisting}
\end{center}
En donde se muestra el uso de method chaining para escribir una consulta a la tabla "Songs" de la cual se van a seleccionar aquellas en donde el atributo "year" sea mayor o igual a 1980 y menor que 1990.

Un punto importante a notar en el ejemplo anterior es que si bien existen operadores relacionales que pueden modificar un "mayor o igual a" por otro operador, el caso de \texttt{attribute("year").ge().value(1980)}, es sem\'anticamente equivalente a \texttt{attribute("year") >= 1980} pero no puede ser mutado.

Esto nos lleva a nuestros objetivos:

\begin{enumerate}[leftmargin=.75cm,align=left]
	\item[Determinar las propiedades que un operador deber\'ia satisfacer]
	Dise\~nar un operador de mutaci\'on no es una tarea trivial, tal como mencionamos anteriormente, mutantes equivalentes al programa original son indeseados, as\'i como aquellos que son trivialmente detectados; los mutantes generados deben representar, estar acoplados a, fallas reales. Definir estas propiedades, de manera precisa y definiendo metodolog\'ias para evaluar a las mismas, es el primer paso para poder dise\~nar un nuevo operador.
	\item[Definir un operador de mutaci\'on para expresiones de navegaci\'on]
	Teniendo en cuenta las propiedades definidas anteriormente y la motivaci\'on para disen\~ar nuevo[s] operadores de mutaci\'on para expresiones de navegaci\'on, es necesario dar una definici\'on de su comportamiento. Esta definici\'on debe ser agn\'ostica al lenguaje de programaci\'on utilizado para implementarlos.
	\item[Implementar el o los operadores de mutaci\'on para expresiones de navegaci\'on] Los operadores existentes actualmente est\'an definidos por reglas de transformaci\'on muy simples, incluso siendo capaz de ser implementados usando expresiones regulares. Modificar una expresi\'on de navegaci\'on requiere informaci\'on de tipos y an\'alisis de alcanzabilidad para determinar las expresiones disponibles al modificar una existente. Es necesario encontrar una herramienta de mutaci\'on que permita realizar el an\'alis necesario para generar estas mutaciones. Elegir un lenguaje sobre el cual y para el cual implementar estos operadores. Y finalmente necesitamos implementar an\'alis apropiados para realizar las evaluaciones necesarios a los mismos.
	\item[Evaluaci\'on]
	Incluso si es cierto que existe una necesidad por la generaci\'on de mutantes para expresiones de navegaci\'on, si el o los operadores que los generan, no cumplen con las propiedades anteriormente descriptas, entonces su utilidad se ve muy reducida. Por eso es necesario evaluar el desempe\~no de \'estos para demostrar su utilidad con respecto a las propiedades de mutantes equivalentes, triviales y acoplamiento a fallas. [REVISAR]
\end{enumerate}

Como objetivo secundario nos interesa el aporte que puede tener la mutaci\'on de expresiones de navegaci\'on en campos como la reparaci\'on autom\'atica de programas basada en mutaci\'on.

%Objetivos

\section{Estado del Arte}
\label{sec:intro.estado-del-arte}
%Estado del arte en mutacion: selection, coupling, subsumption, high order
%Estado del arte en reparacion

Testing es una de las t\'ecnicas m\'as utilizadas para evaluar la correctitud de programas. Siendo testing de regresi\'on, la re-ejecuci\'on de tests para evaluar que el comportamiento correcto del programa no fue incorrectamente alterado durante el desarrollo, uno de los usos m\'as comunes. Es en este \'ultimo donde la limitaci\'on en los recursos a utilizar, tiempo por ejemplo, est\'an m\'as acotados, dado que el desarrollador necesita de manera r\'apida y efectiva validar que mantuvo el comportamiento existente. Esto lleva a buscar criterios de evaluaci\'on de test suites que permitan maximizar la eficiencia del mismo con respecto a capacidad de detectar fallas reales, manteniendo acotada la cantidad de tests requeridos.

Mutation testing es uno de los criterios m\'as utilizados. En donde un test suite es evaluado contra su habilidad de detectar variantes del programa original donde cada una contiene una falla artificial en forma de un cambio sint\'actico simple. Al igual que con el test suite, el conjunto de mutantes utilizados debe mantenerse acotado en cantidad, al mismo tiempo que debe ser capaz de evaluar al mismo de tal forma que la calidad asociada al conjunto de tests est\'e correlacionada con la capacidad del mismo en detectar potenciales fallas.

El estado actual de los avances en mutation testing se puede definir en tres \'ares principales

\subsection{Evaluaci\'on de mutation testing}

Las propiedades de inter\'es en el disen\~no y evoluci\'on de operadores involucrados en mutation testing son, equivalencia de mutantes con el programa original y entre mutantes, dificultad de detecci\'on de mutantes, acoplamiento entre fallas reales y mutantes, y acoplamiento entre mutantes.

\subsubsection{Equivalencia}
Equivalencia [entre dos programas] es una propiedad definida bajo la relaci\'on \texttt{Eq(P, P$\prime$) : $\nexists$ E : P(E) != P$\prime$(E)}, la cual establece que dos programas \texttt{P} y \texttt{P$\prime$} son equivalente si no existe un escenario \texttt{E} tal que el comportamiento de ambos programas se distinto. Esta es una relaci\'on indecidible por lo que m\'etodos incompletos son utilizados. Dentro de mutation testing, equivalencia puede encontrarse entre un mutante y el programa original, un caso indeseable ya que \'estos disminuyen el valor del mutation score sin significar una deficiencia de parte del test suite en detectar ciertas fallas artificiales. Otro caso de equivalencia se da entre mutantes, un caso en donde ambos mutantes son detectados por el test suite, sin embargo al ser equivalente incrementan el valor del mutation score sin significar una mejora de parte del test suite en detectar m\'as fallas artificiales.

Dentro de la investigaci\'on sobre la detecci\'on (evaluaci\'on) de esta caracter\'istica y su impacto en el ana\'alisis de test suites usando mutation testing, \cite{biblography.mutation.evaluation.equivalent.Schuler+10} propone la utilizaci\'on de diferencia en cobertura de c\'odigo y an\'alisis de fujo de datos para determinar potencial equivalencia. Mientras que  \cite{biblography.mutation.evaluation.equivalent.Just+13} utiliza detecci\'on de restricciones condicionales para alcanzar el c\'odigo mutado y \emph{SAT Solving} para determinar si es posible satisfacer dichas restricciones al tiempo que se obtiene un valor distinto al del programa original en ese punto, lo que es similar en principio a \emph{weak mutation}, en donde se considera que un mutante es detectado si en el estado siguiente a la mutaci\'on se detecta una diferencia con el del programa original, pero a\~nadiendo control de alcanzabilidad y una verificaci\'on exhaustiva acotada para detectar si es posible que exista una diferencia.
En \cite{biblography.mutation.evaluation.equivalent.Grun+09} observan que manualmente, para los casos de estudios utilizados, un programador avanzado tarda aproximadamente 15 minutos en promedio para analizar mutantes equivalentes. Y claramente la existencia de equivalentes disminuye artificialmente el mutation score dando la falsa impresi\'on de que es necesario agregar m\'as tests.

\subsubsection{Dificultad de detecci\'on}

As\'i como los mutantes equivalentes son indeseables por ser imposibles de detectar, los mutantes que son solo detectables por un conjunto peque\~no de tests, son altamente deseables. Estos son denominados \emph{stubborn} \cite{bibliography.mutation.evaluation.stubbornHieronsHD99}. La detecci\'on de estos mutantes requieren tests de "mejor calidad" y si bien existen estudios que eval\'uan la generaci\'on de stubborns por operador \cite{bibliography.mutation.evaluation.stubborn}, \'este depende del conjunto de programas utilizados y los tests asociados. Con respecto a este obst\'aculo, en \cite{bibliography.mutation.evaluation.hardnessVisser}, proponen el uso de \emph{model counting} sobre programas m\'as simples pero utilizando un estudio m\'as exhaustivo.

\subsubsection{Subsunci\'on}

\emph{Subsumption}, la relaci\'on entre mutantes con respecto a los tests que los detectan, dan lugar a mutantes redundantes. Esto es, los tests que detectan al mutante subsumido, incluyen a aquellos que detectan al que subsume, es decir, el mutante subsumido eval\'ua de manera menos espec\'ifica a los tests ya que es detectado por una mayor cantidad, mientras que el que subsume eval\'ua tests m\'as espec\'ificos. Esto lleva a mutantes redundantes y representa una forma de evaluar la dificultad de detecci\'on, los mutantes que subsumen a otros pero no son a su vez subsumidos, son detectados por pocos tests. Presentado inicialmente en \cite{bibliography.mutation.selection.Offutt96}, mutant subsumption es utilizado por \cite{bibliography.mutation.minimizing.dynamicsubsumption} y \cite{bibliography.mutation.evaluation.JustKA17} para evaluar utilidad de mutantes dentro de mutation analysis.

\subsubsection{Acoplamiento}

\emph{Coupling}, el acoplamiento entre fallas reales y mutantes es una propiedad altamente deseable, sin la misma, mutation testing perder\'ia su utilidad al desaparecer la correlaci\'on entre un mutation score alto y una buena capacidad de parte del test suite para detectar fallas reales. El trabajo m\'as importante sobre este tema, y uno que nos representa una motivaci\'on importante para el desarrollo de nuestros operadores de mutaci\'on presentados en esta tesis, es \cite{bibliography.mutation.evaluation.valid-substitute}. El acoplamiento entre mutantes y fallas reales es una relaci\'on que especifica que si un conjunto de tests detecta un conjunto de mutantes, entonces va a detectar una falla real. 

\subsection{High order}

\texttt{High Order}, la combinaci\'on de mutaciones, generada al aplicar operadores de mutaci\'on m\'as de una vez al generar un mutante, se denominan mutaciones de alto order mientras que aquellas que la forman, se las llama de primer orden. Si bien en principio esto agregar\'ia una gran cantidad de nuevos mutantes\footnote{Usualmente la cantidad de mutantes al aplicar m\'as de una mutaci\'on por mutante est\'a acotada por M$_0^G$ en donde \texttt{M$_0$} son la cantidad de mutantes de primer orden y \texttt{G} son la cantidad de mutaciones por mutante}, los estudios actuales que se enfocan en esta t\'ecnica concluyen que estos mutantes de alto orden representan fallas artificiales m\'as sutiles y que subsumen a una gran cantidad de mutantes de primer orden. [AGREGAR]

\subsection{Reparaci\'on autom\'atica de programas}

En reparaci\'on autom'atica de programas, una de los argumentos m\'as utilizados es que por un lado, cuando existe una falla, la versi\'on del programa sin la misma es muy cercana, sint\'acticamente, a la primera. Por otro lado el c\'odigo asociado a la reparaci\'on es, en muchos casos, una reorganizaci\'on (eliminaci\'on, desplazamiento, o duplicaci\'on) de c\'odigo existente; una alteraci\'on, es decir, un cambio sint\'actico, de c\'odigo existente; o una combinaci\'on de ambas. Dentro de t\'ecnicas de reparaci\'on asociadas mayormente a la primer categor\'ia se encuentran [AGREGAR]. La segunda categor\'ia est\'a muchas veces asociada a el uso de mutation dentro del contexto de reparaci\'on, el argumento es que existen mutaciones que si se fueran a combinar, se cancelar\'ian, por ejemplo:
\lstinline|for (int i = 0; i < lenght; i++)...| se puede mutar, aplicando un cambio de operador relacional, a \lstinline|for (int i = 0; i > lenght; i++)...|, que a su vez se puede mutar al c\'odigo original aplicando el mismo operador de mutaci\'on. Aunque no siempre se puede deshacer una mutaci\'on aplicando otra que sea sint\'acticamente inversa. Volviendo al ejemplo anterior, el mutante \lstinline|for (int i = 0; i > lenght; i++)...| se puede restaurar, sem\'anticamente, generando el mutante \lstinline|for (int i = 0; i != lenght; i++)...|. Existen tambi\'en casos donde varias mutaciones pueden restaurar el comportamiento. Esto lleva a la idea de que si consideramos el programa con fallas \texttt{P$_b$} y el original sin fallas \texttt{P$_o$}, se puede definir el segundo en t\'erminos del primero como \texttt{P$_b$ = mutate(P$_o$, M)} donde \texttt{M} representa una secuencia de mutaciones y \texttt{mutate} es un programa que aplica dicha secuencia a un programa. En general como dijimos anteriormente, toda mutaci\'on tiene su inversa, lo que lleva a definir el problema de reparaci\'on como encontrar una secuencia de mutaciones \texttt{M$\prime$} tal que \texttt{P$_o$ = mutate(P$_b$, M$\prime$)}. Herramientas que tratan este caso, el de reparar programas utilizando mutaci\'on o una combinaci\'on entre mutaci\'on y reorganizaci\'on de c\'odigo incluyen [AGREGAR]

\section{Contribuciones}
\label{sec:intro.contribuciones}
%TODO: Describir porque nuestras t\'ecnicas mejoran o complementan las t\'ecnicas de an\'alisis autom\'aticos existentes. Cuales y porque son los casos de estudios utilizados para validar cada una de las t\'ecnicas.
%\begin{itemize}
%\item operacionalizacion
%\item amplitud de objetivos (liveness)
%\item abstraccion
%\item escalabilidad
%\item herramientas
%\end{itemize}

%Se pueden mencionar papers publicados

La definici\'on e implementaci\'on de una familia de operadores de mutaci\'on para expresiones de navegaci\'on, dentro del contexto de mutation testing, es la principal contribuci\'on de este trabajo. Dado que la mutaci\'on de expresiones de navegaci\'on generar\'ia en principio una cantidad inmanejable de mutantes, es necesario encontrar y definir el tipo de fallas que se desean generar. Incluso si la generaci\'on de mutantes para expresiones de navegaci\'on representa un conjunto de fallas no representadas actualmente, no solo alcanza con satisfacer la necesidad de fallas artificiales previamente no representadas, sino tambi\'en es necesario evaluar que el rendimiento de mutation testing no se vea significativamente afectado de forma negativa al agregar estos operadores. Espef\'iciamente en esta tesis presentaremos las siguientes contribuciones principales:

\begin{enumerate}
	\item Mostrar la necesidad de generar mutantes para expresiones de navegaci\'on. El conjunto de \emph{operadores suficientes} de mutaci\'on, ha permanecido pr\'acticamente inalterado desde hace a\~nos, si bien el primer trabajo que ofrece un conjunto de operadores formalmente definidos lo hace para el lenguaje FORTRAN \cite{bibliography.mutation.definitions.fortranOffut87, bibliography.mutation.definitions.fortranKing91}, mutation testing fue siendo aplicado y evaluado en varios lenguajes incluyendo aquellos considerados orientados a objetos (ADA, JAVA, entre otros). Sin embargo los operadores de mutaci\'on espec\'ificos para lenguajes orientados a objetos solo afectan, en general, jerarqu\'ia de clases y sobre-escritura. En el trabajo de \cite{bibliography.mutation.evaluation.valid-substitute} se expone la necesidad de mejorar operadores de mutaci\'on o desarrollar nuevos operadores, para poder representar cierto tipos de fallas reales no representadas actualmente. Nuestra primer contribuci\'on es evidenciar la necesidad de representar fallas relacionadas a expresiones de navegaci\'on com\'unmente encontradas en lenguajes orientados a objetos.
	
	\item Dar una definici\'on formal de operadores para expresiones de navegaci\'on. Si bien la implementaci\'on que se ofrece en esta tesis es implementada en una herramienta espec\'ifica para un lenguaje particular, la definici\'on de los operadores deber\'ia permitir su implementaci\'on en cualquier herramienta y lenguaje. Una de las razones para esto incluye su utilizaci\'on para lenguajes de modelado, como Alloy \cite{bibliography.books.SoftwareAbstractions-alloy}, basados en trabajos como \cite{bibliography.repair.mutation.AlloyWang18} que propone una herramienta de reparaci\'on de modelos escritos en este lenguaje, y \cite{bibliography.algebraicExpressions.RexGenWang18} que expone la necesidad de la generaci\'on autom\'atica de expresiones en \'algebra relacional para distintos campos, entre ellos, reparaci\'on autom\'atica y ayudas al desarrollador (tooltips autom\'aticos).
	
	\item Implementar la familia de operadores para expresiones de navegaci\'on. Nuestra implementaci\'on est\'a enfocada al lenguaje \emph{Java}, dado que es un buen representante de lenguajes orientados a objetos. Nuestra implementaci\'on est\'a realizada en una versi\'on modificada de \emph{$\mu$Java} \cite{bibliography.mutation.tools.muJavaMaOK05}, que nos permite realizar an\'alisis de tipos y alcanzabilidad que otras herramientas no permiten. Aprovecharemos para implementar distintos an\'alisis que usaremos durante la evaluaci\'on como \emph{dureza}(toughness) que mide cuantos tests fue capaz de sobrevivir un mutante antes de ser detectado, este valor puede ser tomado como un indicador de cuan dif\'icil es detectar un mutante, y permitir\'ia sacar conclusiones sobre la dificultad de los mutantes generados por un operador; \emph{subsumci\'on}(subsumption) de mutantes, es un an\'alis que permite poner en evidencia para un programa particular, con un conjunto de tests particular, mutantes redundantes. Una caracter\'istica de nuestra implementaci\'on es la capacidad de configurar la familia de operadores para expresiones de navegaci\'on para poder proveer la mayor eficiencia para cada caso de estudio.
\end{enumerate}

Evaluaremos nuestra familia de operadores para expresiones de navegaci\'on bajo, mayormente, estructuras de datos [BENCHMARK]. Contrastaremos el efecto de agregar estos operadores al conjunto suficiente de operadores definidos en la literatura y que se encuentran implementados en \emph{$mu$Java}. Es necesario considerar que nuestra versi\'on modificada de esta herramienta contiene numerosas mejoras a los operadores ya existentes, principalmente validaciones faltantes para evitar la generaci\'on de mutantes que no compilan (un subconjunto de los mutantes triviales) como por ejemplo no agregar el operador \texttt{++} a una expresi\'on constante.
[AGREGAR]


\section{Organizaci\'on}
\label{sec:intro.organizacion}
%TODO: Cuales van a ser los temas de cada capitulo desarrollado en este trabajo.


