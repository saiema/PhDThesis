\chapter{Mutaci\'on de expresiones de navegaci\'on en reparaci\'on de programas}
\label{cap:repair}

\section{Reparaci\'on autom\'atica de programas}
\label{sec:repair}

La aparici\'on de t\'ecnicas autom\'aticas para testing y localizaci\'on de fallas, es decir, detectar en donde puede estar una falla, una vez detectada, llev\'o a la investigaci\'on de t\'ecnicas para, una vez detectada, poder reparar dicha falla de manera autom\'atica. Pero que significa reparar una falla?
\begin{quote}
	Dado un programa \textbf{P} y una especificaci\'on \textbf{E} del mismo, si \textbf{P} no cumple con sus especificaciones (\textbf{R}), repara al programa significa encontrar un variante \textbf{P'} mediante modificaciones sint\'acticas tal que \'esta cumpla con las especificaciones dadas por \textbf{E} \footnote{Esta definici\'on no considera reparaciones en tiempo de ejecuci\'on, es decir, aquellas que no producen una variante del programa original como reparaci\'on}.
\end{quote}
A partir del trabajo de \cite{bibliography.repair.ArcuriY08}, muchas herramientas que intentan atacar a este problema han surgido. Incluso cuando la idea de reparaci\'on autom\'atica de fallas es atractiva, reparar autom\'aticamente defectos de programas arbitrarios es inviable. Por lo tanto, la reparaci\'on autom\'atica de programas debe sacrificar completitud. Varias t\'ecnicas efectivas para reparaci\'on de programas recurren a explorar un conjunto grande (aunque limitado) de candidatos de reparaci\'on obtenidos por modificaciones sint\'acticas de un programa con fallas. Adem\'as, para que estas t\'ecnicas escalen razonzablemente, el espacio de candidatos a reparaci\'on debe ser acotado, limitando el conjunto de modificaciones sint\'acticas a considerar (por ejemplo, no considerar modificaciones a partes de una sentencia), o no explorando exhaustivamente el conjunto acotado de candidatos a reparaci\'on (por ejemplo, usando algor\'itmos gen\'eticos en lugar de b\'usqueda exhaustiva).

\subsection{Or\'aculo de reparaci\'on}
\label{sec:repair.specs}

En general el proceso de reparaci\'on sigue, a rasgos muy generales, el siguiente algoritmo:

\begin{lstlisting}
	repair(P, E)
		current = P
		while (!isValid(current, E) && !boundsReached()) {
			current = nextFix();
		}
		return current;
\end{lstlisting}

Donde \textbf{P} representa el programa a reparar, y \textbf{E} las especificaciones que se deben satisfacer. El proceso b\'usca candidatos a reparaciones, evaluando a \'estos con respecto a las especificaciones provistas. Claramente el proceso est\'a acotado a un conjunto finito de posibles reparaciones.

Evidentemente, es necesario definir que se usa como especificaciones para el programa. Los primeros trabajos sobre reparaci\'on autom\'atica \cite{bibliography.repair.StaberJB05, bibliography.repair.ArcuriY08}, utilizaban especificaciones formales en forma de pre y post condiciones, o descripciones l\'ogicas provistas en alg\'un formalismo l\'ogico apropiado. Sin embargo, muchos de las \'ultimas t\'ecnicas utilizan tests como especificaciones. La raz\'on principal detr\'as de esto, es el argumento de que la producci\'on de especificaciones formales es un proceso costoso, a la vez que es muy raro encontrarlas ya provistas previo al proceso de reparaci\'on, mientras que los tests son menos costosos de proveer y es mucho m\'as com\'un encontrarlos ya provistos antes del proceso de reparaci\'on.

%EL RESTO HAY QUE REESCRIBILO/REORGANIZARLO

Por ejemplo, \emph{GenProg} \cite{bibliography.repair.GouesNFW12} usa computaci\'on evolutiva para evolucionar sint\'acticamente un programa hasta que una reparaci\'on aceptable es encontrada. Cada reparaci\'on candidata (modificaci\'on sint\'actica) es aplicada al programa original para producir uno nuevo cuya aptitud es evaluada utilizando un test suite. Modificaciones sint\'acticas en partes de una sentencia no son consideradas para limitar el espacio de candidatos, y la funci\'on de aptitud es utilizada para mantener una poblaci\'on reducida de candidatos a lo largo del proceso de computaci\'on evolutiva. En \emph{PAR} \cite{bibliography.repair.KimNSK13}, las modificaciones para reparar el programa son aprendidas a partir de patrones en reparaciones escritas manualmente. Por \'esto, el n\'umero de candidatos a considerar como reparaciones es significativamente reducido, lo que a su vez reduce el tipo de errores que la t\'ecnica puede ser capaz de reparar.

Modificaciones a partes de sentencias, es decir, aquellas que alteran expresiones dentro de una sentencia, son en general no consideradas por t\'ecnicas de reparaci\'on de programas. Una limitaci\'on principal al considerar a \'estas, es la explosi\'on en el espacio de candidatos de reparaci\'on. T\'ecnicas que utilizan operadores de mutaci\'on para producir las modificaciones sint\'acticas, y que incluyen modificaciones a partes de sentencias, requieren limitar el conjunto de mutaciones (por ejemplo, \cite{bibliography.repair.GopinathMK11}), reduciendo la clase de fallas que \'estas pueden intentar reparar.

La categor\'ia de t\'ecnicas de reparaci\'on de programas que nos interesa, es la basada en la utilizaci\'on de operadores de mutaci\'on para producir las reparaciones (modificaciones sint\'acticas). El argumento de \'estas es que existen mutaciones que si se fueran a combinar, se cancelar\'ian, por ejemplo:
\begin{lstlisting}[mathescape=true]
  for (int i = 0; i < lenght; i++)...
  $\delta$for (int i = 0; i > lenght; i++)...
\end{lstlisting}
donde la primera sentencia se puede mutar, aplicando un cambio de operador relacional, a la segunda, marcada por $\delta$, que a su vez se puede mutar al c\'odigo original aplicando el mismo operador de mutaci\'on. Aunque no siempre se puede deshacer una mutaci\'on aplicando otra que sea sint\'acticamente inversa. 
Volviendo al ejemplo anterior, el mutante:
\begin{lstlisting}[mathescape=true]
  for (int i = 0; i > lenght; i++)...
\end{lstlisting}
puede ser restaurado, sem\'anticamente, generando el mutante:
\begin{lstlisting}[mathescape=true]
  for (int i = 0; i $\textbf{!=}$ lenght; i++)...
\end{lstlisting}
Existen tambi\'en casos donde varias mutaciones pueden corregir el comportamiento. Esto lleva a la idea de que si consideramos el programa con fallas \texttt{P$_b$} y el original sin fallas \texttt{P$_o$}, se puede definir el segundo en t\'erminos del primero como \texttt{P$_b$ = mutate(P$_o$, M)} donde \texttt{M} representa una secuencia de mutaciones y \texttt{mutate} es un programa que aplica dicha secuencia a un programa. En general como dijimos anteriormente, toda mutaci\'on tiene su inversa, lo que lleva a definir el problema de reparaci\'on como encontrar una secuencia de mutaciones \texttt{M$\prime$} tal que \texttt{P$_o$ = mutate(P$_b$, M$\prime$)}.

\section{Striker}
\label{sec:repair.striker}

Si bien muchas herramientas de reparaci\'on autom\'atica de programas utilizan mutaci\'on, \emph{Striker} es una de las m\'as flexibles con respecto a operadores soportados, entre ellos \emph{prvo}; soporte para modificaciones a partes de sentencias; y fallas que requieren las modificaci\'on de varias sentencias. Striker utiliza \emph{TACO} \cite{bibliography.mutation.tools.TACOGaleottiRPF13} para evaluar candidatos a reparaci\'on, lo que requiere proveer especificaciones formales en lugar de un test suite, y JML RAC \cite{bibliography.misc.JMLRAC.LeavensCCRC02} como t\'ecnica de evaluaci\'on r\'apida basada en escenarios previamente encontrados para los cuales un candidato a reparaci\'on no cumpl\'ia con las especificaciones. Sin entrar en detalles, esta herramienta es capaz de expandir las fallas soportadas para reparar, agregando varios operadores en los que incluye a \emph{prvo}, y permitir la reparaci\'on de aquellas que requieren modificaciones intra-sentencias as\'i como en m\'ultiples sentencias, mediante el uso de t\'ecnicas de poda innovadoras.

Bajo esta herramienta es que se pudo observar como \emph{prvo} era capaz de reparar ciertas fallas que de otra forma no eran reparables. Si bien el enfoque principal de esta tesis se encuentra en \emph{prvo} como un operador de mutaci\'on en el contexto de mutation testing, es interesante mostrar su contribuci\'on en el contexto de reparaci\'on.