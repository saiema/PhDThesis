\chapter[Reparaci\'on]{Reparaci\'on autom\'atica de programas}
\label{sec:preliminares.repair}

La aparici\'on de t\'ecnicas autom\'aticas para testing y localizaci\'on de fallas, es decir, detectar en donde puede estar una falla, una vez detectada, llev\'o a la investigaci\'on de t\'ecnicas para, una vez detectada una falla, poder repararla de manera autom\'atica. A partir del trabajo de \cite{bibliography.repair.ArcuriY08}, muchas herramientas que intentan atacar a este problema han surgido. Incluso cuando la idea de reparaci\'on autom\'atica de fallas es atractiva, reparar autom\'aticamente defectos de programas arbitrarios es inviable. Por lo tanto, la reparaci\'on autom\'atica de programas debe sacrificar completitud. Varias t\'ecnicas efectivas para reparaci\'on de programas recurren a explorar un conjunto grande (aunque limitado) de candidatos de reparaci\'on obtenidos por modificaciones sint\'acticas de un programa con fallas. Adem\'as, para que estas t\'ecnicas escalen razonzablemente, el espacio de candidatos a reparaci\'on debe ser acotado, limitando el conjunto de modificaciones sint\'acticas a considerar (por ejemplo, no considerar modificaciones a partes de una sentencia), o no explorando exhaustivamente el conjunto acotado de candidatos a reparaci\'on (por ejemplo, usando algor\'itmos gen\'eticos en lugar de b\'usqueda exhaustiva). Por ejemplo, \emph{GenProg} \cite{bibliography.repair.GouesNFW12} usa computaci\'on evolutiva para evolucionar sint\'acticamente un programa hasta que una reparaci\'on aceptable es encontrada. Cada reparaci\'on candidata (modificaci\'on sint\'actica) es aplicada al programa original para producir uno nuevo cuya aptitud es evaluada utilizando un test suite. Modificaciones sint\'acticas en partes de una sentencia no son consideradas para limitar el espacio de candidatos, y la funci\'on de aptitud es utilizada para mantener una poblaci\'on reducida de candidatos a lo largo del proceso de computaci\'on evolutiva. En \emph{PAR} \cite{bibliography.repair.KimNSK13}, las modificaciones para reparar el programa son aprendidas a partir de patrones en reparaciones escritas manualmente. Por \'esto, el n\'umero de candidatos a considerar como reparaciones es significativamente reducido, lo que a su vez reduce el tipo de errores que la t\'ecnica puede ser capaz de reparar.

Modificaciones a partes de sentencias, es decir, aquellas que alteran expresiones dentro de una sentencia, son en general no consideradas por t\'ecnicas de reparaci\'on de programas. Una limitaci\'on principal al considerar a \'estas, es la explosi\'on en el espacio de candidatos de reparaci\'on. T\'ecnicas que utilizan operadores de mutaci\'on para producir las modificaciones sint\'acticas, y que incluyen modificaciones a partes de sentencias, requieren limitar el conjunto de mutaciones (por ejemplo, \cite{bibliography.repair.GopinathMK11}), reduciendo la clase de fallas que \'estas pueden intentar reparar.

La categor\'ia de t\'ecnicas de reparaci\'on de programas que nos interesa, es la basada en la utilizaci\'on de operadores de mutaci\'on para producir las reparaciones (modificaciones sint\'acticas). El argumento de \'estas es que existen mutaciones que si se fueran a combinar, se cancelar\'ian, por ejemplo:
\lstinline|for (int i = 0; i < lenght; i++)...| se puede mutar, aplicando un cambio de operador relacional, a \lstinline|for (int i = 0; i > lenght; i++)...|, que a su vez se puede mutar al c\'odigo original aplicando el mismo operador de mutaci\'on. Aunque no siempre se puede deshacer una mutaci\'on aplicando otra que sea sint\'acticamente inversa. Volviendo al ejemplo anterior, el mutante \lstinline|for (int i = 0; i > lenght; i++)...| se puede restaurar, sem\'anticamente, generando el mutante \lstinline|for (int i = 0; i != lenght; i++)...|. Existen tambi\'en casos donde varias mutaciones pueden corregir el comportamiento. Esto lleva a la idea de que si consideramos el programa con fallas \texttt{P$_b$} y el original sin fallas \texttt{P$_o$}, se puede definir el segundo en t\'erminos del primero como \texttt{P$_b$ = mutate(P$_o$, M)} donde \texttt{M} representa una secuencia de mutaciones y \texttt{mutate} es un programa que aplica dicha secuencia a un programa. En general como dijimos anteriormente, toda mutaci\'on tiene su inversa, lo que lleva a definir el problema de reparaci\'on como encontrar una secuencia de mutaciones \texttt{M$\prime$} tal que \texttt{P$_o$ = mutate(P$_b$, M$\prime$)}.

\section{Striker}
\label{sec:preliminares.repair.striker}

Si bien muchas herramientas de reparaci\'on autom\'atica de programas utilizan mutaci\'on, \emph{Striker} es una de las m\'as flexibles con respecto a operadores soportados, entre ellos \emph{prvo}; soporte para modificaciones a partes de sentencias; y fallas que requieren las modificaci\'on de varias sentencias. Striker utiliza \emph{TACO} \cite{bibliography.mutation.tools.TACOGaleottiRPF13} para evaluar candidatos a reparaci\'on, lo que requiere proveer especificaciones formales en lugar de un test suite, y JML RAC \cite{bibliography.misc.JMLRAC.LeavensCCRC02} como t\'ecnica de evaluaci\'on r\'apida basada en escenarios previamente encontrados para los cuales un candidato a reparaci\'on no cumpl\'ia con las especificaciones. [AGREGAR]