%!TEX root = main.tex
\chapter[Implementaci\'on]{PRVO y $\mu$Java++}
\label{cap:implementation}

\section{$\mu$Java++}

La herramienta \emph{$\mu$Java} \cite{bibliography.mutation.tools.muJavaMaOK05} funciona traduciendo c\'odigo fuente \emph{Java} a un \emph{AST}, una estructura de \'arbol que representa el c\'odigo original como nodos, y recorriendo el mismo mediante un patr\'on \emph{visitor}. Cada operador sobreescribe m\'etodos particulares de visita para los nodos objetivo, el operador \emph{ROR}, por ejemplo, solo tiene por objetivo a expresiones binarias (en cuanto al tipo de nodos) y particularmente a aquellas que utilicen un operador relacional. En la Figura \ref{figures.examples.rorMutation} se ve una parte de un \emph{AST} correspondiente a la sentencia \lstinline|x = y < 0|, \emph{ROR} al visitar el nodo \emph{BinExpr} con el operador \emph{<}, va a generar varias mutaciones, entre otras, el nodo mutado \emph{BinExpr[>]} que corresponde al cambio de el operador \emph{<} por \emph{>}, mientras mantiene los subnodos de \emph{BinExpr} sin modificaciones.

\begin{figure}
	\begin{tikzpicture}%
	[state/.style ={ellipse, draw, minimum width = 0.7 cm},
	point/.style = {circle, draw, inner sep=0.04cm,fill,node contents={}},
	el/.style = {inner sep=2pt, align=left, sloped}]
	\node[state,rectangle] (asg) {$Assignment$};
	\node[state,rectangle] (varx) [below=of asg] {$Var[x]$};
	\node[state,rectangle] (bexpr) [right=of varx] {$BinExpr[<]$};
	\node[state,rectangle] (vary) [below=of bexpr] {$Var[y]$};
	\node[state,rectangle] (lit) [right=of vary] {$Lit[0]$};
	
	\path (asg) edge (varx);
	\path (asg) edge (bexpr);
	\path (bexpr) edge (vary);
	\path (bexpr) edge (lit);
	
	\node[draw=blue,dotted,fit=(bexpr) (vary) (lit), inner sep=0.2cm] (binaryO) {};
	
	\node[state, rectangle] (bexprM) [right=of binaryO] {$BinExpr[>]$};
	
	\path[->] (binaryO) edge[bend left=20] node[above] {ROR} (bexprM);
	\path (bexprM) edge[bend right=20] (vary);
	\path (bexprM) edge[bend right=20] (lit);
	
	\end{tikzpicture}
	\caption{Ejemplo del operador \emph{ROR} en funcionamiento}
	\label{figures.examples.rorMutation}
\end{figure}

Una de las primeras tareas para poder desarrollar \emph{prvo}, fue la reimplementaci\'on de esta herramienta. Hay dos herramientas involucradas, una es \emph{OJ}, anteriormente conocida como \emph{OpenJava}, que permite la transformaci\'on de c\'odigo fuente \emph{Java} en un \emph{AST}, as\'i como ofrecer clases para el recorrido y modificaci\'on de el mismo. \'Esta es la base que utiliza \emph{$\mu$Java}, y actualmente \emph{$\mu$Java++}. Ambas herramientas fueron altamente modificadas, con \emph{$\mu$Java} siendo pr\'acticamente reescrita por completo. Las razones para realizar dicha tarea tiene que ver con una serie de requerimientos que definimos a continuaci\'on:

\subsection{Representaci\'on}

Originalmente, las mutaciones no estaban representadas en \emph{$mu$Java}, los mutantes se generaban directamente, muchas veces como una responsabilidad del operador. Al dise\~nar \emph{prvo}, observamos que era muy f\'acil generar mutaciones repetidas, tomemos por ejemplo la expresi\'on \lstinline|a.b.c|, es posible generar \lstinline|a.c| eliminando la subexpresi\'on del medio, pero tambi\'en es posible al reemplazar las dos primeras por \lstinline|a|. Al mismo tiempo, la variable especial \lstinline|this|, permite que para todo campo de una clase, haya dos formas de referirse al mismo, una mediante el uso de \lstinline|this|, y otra obviando el mismo. Por otro lado, \emph{prvo} estaba siendo muy utilizado en el desarrollo de \emph{Stryker}, herramienta de reparaci\'on autom\'atica mediante mutaci\'on y \emph{SAT solving}, vista en la secci\'on \ref{sec:repair.striker}. La necesidad de contar con cierta informaci\'on sobre las mutaciones para permitir ordenar e incluso ignorar algunas durante la b\'usqueda de un potencial arreglo, nos llev\'o a definir una representaci\'on para las mutaciones generadas mediante ternas \texttt{(original, mutante, operador)} en donde los dos primeros elementos representan nodos del \emph{AST} y el tercero denota el operador utilizado. \'Estas se almacenan durante la generaci\'on de mutaciones hasta que se decida generar los mutantes, esto permite, entre otras cosas, analizar y evitar mutaciones repetidas.

\subsection{Anotaciones y control de generaciones}

Las herramientas de mutaci\'on, suele o bien no contar con un control sobre que partes de c\'odigo se van a mutar, o \'este es muy grueso, por ejemplo al permitir definir clases y m\'etodos a mutar. Debido nuevamente a los comienzos orientados a reparaci\'on de \emph{prvo}, necesit\'abamos un control m\'as fino sobre donde se aplicar\'ian las mutaciones. Lo que nos llev\'o, adem\'as de permitir definir que m\'etodos se permiten mutar, a utilizar comentarios \lstinline|//mutGenLimit K| luego de una sentencia para permitir que solo aquellas que tengan estas anotaciones y el \emph{K} sea mayor a 0, sean mutadas.

A su vez, las anotaciones utilizadas son escritas en el mutante con el \emph{K} asociado disminu\'ido en 1. Esto permite, en casos como reparaci\'on o generaci\'on de mutantes compuestos (aquellos con m\'as de una mutaci\'on aplicada), controlar las generaciones m\'aximas por sentencia.

\subsection{Estandarizaci\'on de componentes}

La versi\'on original de la herramienta ten\'ia implementaci\'ones muy diferentes por operador, algunos escrib\'ian directamente cada mutante (sin tener una representaci\'on para las mutaciones aplicadas), esto hac\'ia que desarrollar nuevos operadores fuera una tarea compleja, nuestra versi\'on permite desarrollar nuevos operadores con relativa facilidad. Durante el desarrollo de \emph{prvo}, tuvimos en cuenta que en el futuro podr\'iamos querer implementar nuevos operadores, y funcionalidades, lo que nos llev\'o a re-dise\~nar grandes partes de la herramienta. Gracias a esto, pudimos utilizar a \emph{$mu$Java++} para desarrollar otro operador de mutaci\'on, \emph{BEE}, centrado en generar mutaciones para fortalecer y debilitar expresiones condicionales de una manera m\'as fina que operadores existentes, a su vez, pudimos implementar funcionalidades de an\'alisis descriptas a continuaci\'on.

\subsection{Evaluaci\'on}

Mutation testing consiste en generar mutantes y evaluar cuantos son detectados por el conjunto de tests en evaluaci\'on. En la secci\'on \ref{sec:preliminares.mutation.opevaluation} se mencionan varias caracter\'isticas que afectan a este criterio, en particular dificultad de detecci\'on y redundancia de mutantes. Nuestra versi\'on de \emph{$\mu$Java} provee ciertas mejoras en el an\'alisis con respecto a estas propiedades, como ofrecer dos valores de \emph{mutation score}, uno en donde se consideran los mutantes que no compilaron y otro donde no se los considera. Si bien, una evaluaci\'on inicial y muy b\'asica de dificultad de detecci\'on, \emph{$mu$Java++} ofrece un an\'alisis de ``dureza'' de los mutantes, al analizar, cuantos tests fue capaz de sobrevivir cada mutante. Con respecto a redundancia, un an\'alisis m\'as complejo que ofrece nuestra herramienta, es \emph{dynamic mutant subsumption}, en donde se genera un grafo de subsuma de mutantes para la test suite particular, permitiendo evaluar que mutantes fueron redundantes y cuales son indispensables. Finalmente, para lidiar con la explosi\'on de mutantes que se puede dar, y c\'omo el rendimiento es afectado por eso, se implementaron la capacidad de frenar la ejecuci\'on de los tests para un mutante cuando \'este es detectado (perdiendo ciertos an\'alisis que requieren datos completos de la ejecuci\'on de los tests), y el an\'alisis en paralelo de mutantes para acelerar el proceso.

\section{PRVO}
\label{sec:implementation.prvo}

La definici\'on general de \emph{prvo}, dada en \ref{sec:prvo.prvo}, no es efectiva en la pr\'actica, desde ya por que permite entre otras cosas, infinitas mutaciones. Si bien mencionamos, e incluso presentamos a \emph{prvo} como un meta-operador altamente configurable, es necesario establecer algunas restricciones b\'asicas, ya que mientras m\'as flexible es un operador, m\'as compleja es su implementaci\'on. Por esta raz\'on, es que decidimos fijar ciertas restricciones iniciales, basadas en la evoluci\'on de \emph{prvo} durante su desarrollo, tanto en su uso en reparaci\'on, como en mutation testing.

Inicialmente \emph{prvo} comienza como una necesidad en reparaci\'on autom\'atica de programas mediante mutaci\'on y \emph{SAT solving}. Utilizando la herramienta \emph{Stryker}, \emph{prvo} provee el potencial de reparar ciertos defectos no reparables anteriormente mediante mutantes. Como un problema que se menciona en \ref{cap:repair}, la explosi\'on de candidatos en el espacio de b\'usqueda es uno de los principales obst\'aculos en reparaci\'on autom\'atica basada en mutaci\'on. Por esto, \emph{prvo} comienza con una serie de restricciones sobre el tama\~no de las expresiones mutadas, la diferencia entre el tama\~no original y final de una expresi\'on no puede superar a \texttt{1}. Estas restricciones llevan a una gram\'atica ligeramente distinta a la original.

\begin{figure}
	\begin{displaymath}
	\begin{array}{lll}
  PRVO(x)		& :=	& expression^{|0-1|} \\
  & := & x.expression^{|0|} \\
  & := & expression^{|0|}.x \\
  & := & null \\
	
  \\
  PRVO(x.y)	& :=	& x \\
  & :=	& 	y \\
  & :=	& expression^{|0-1|}.y \\
  & :=	& y.expression^{|0-1|} \\
  & :=	& expression^{|0|} \\
  & :=	& x.y.expression^{|0|} \\
  & :=	& x.expression^{|0|}.y \\
  & :=	& expression^{|0|}.x.y \\
  \\
	
	\end{array}
	\end{displaymath}
	\caption{Definici\'on base de la implementaci\'on de \emph{prvo}}
	\label{figures.definitions.prvo.impl_def}
\end{figure}

En la Figura \ref{figures.definitions.prvo.impl_def} se restringe la definici\'on abstracta de \emph{prvo} [\ref{figures.definitions.prvo.simple_def}] en base a cuanto se puede cambiar la longitud de la expresi\'on original. La notaci\'on \emph{expression$^{|R|}$} denota una expresi\'on encadenada de un tama\~no particular o un rango de tama\~nos, por ejemplo, de 0 a 1. El valor \emph{null} es un caso especial, no es posible incrementar el tama\~no de una expresi\'on encadenando nuevos elementos ni tampoco reemplazar \emph{null} por una expresi\'on de tama\~no 1, solo es posible reemplazarlo por otra expresi\'on de tama\~no 0.

\subsection{Configuraci\'on de PRVO}

Con el tiempo la cantidad de comportamientos o restricciones configurables en \emph{prvo} fue aumentando. En esta secci\'on solo mencionaremos un conjunto de \'estas, ya que varias fueron implementadas para casos muy particulares.

\subsubsection{Restricciones de tama\~no}
\label{sec:implementation.prvo.restrictions.size}

A partir de la definici\'on en la Figura \ref{figures.definitions.prvo.impl_def}, las restricciones sobre cuanto puede decrementar o incrementar una expresi\'on encadenada se limitan a:

\begin{enumerate}[leftmargin=.75cm,align=left]
	\item[\textbf{Reemplazar un elemento (R)}] Ciertas mutaciones de \emph{prvo} solo modifican elementos unitarios (expresiones de tama\~no 0) en una expresi\'on encadenada, reemplaz\'andolos por otros de tama\~no 0.
	
	\item[\textbf{A\~nadir un elemento (A)}] Una expresi\'on encadenada puede incrementarse por 1 su tama\~no, al insertar un elemento tanto al principio, al final, o intercalarlo en su interior.
	
	\item[\textbf{Eliminar un elemento (D)}] En una expresi\'on de navegaci\'on, se puede eliminar un elemento, ya sea al principio, final, o en el resto de la expresi\'on. No es posible eliminar un elemento en una expresi\'on encadenada de tama\~no 0, ya que no est\'a definida una expresi\'on de menor tama\~no.
	
	\item[\textbf{Intercambiar dos elementos por uno (2x1)}] Dada una expresi\'on de navegaci\'on, dos elementos contiguos, es decir, una subexpresi\'on de navegaci\'on de tama\~no 1, puede ser reemplazada por un \'unico elemento, es decir, una expresi\'on encadenada de tama\~no 0.
	
	\item[\textbf{Intercambiar un elemento por dos (1x2)}] En una expresi\'on encadenada, un elemento de la misma puede ser reemplazado por dos elementos contiguos, es decir, una expresi\'on de navegaci\'on de tama\~no 1.
\end{enumerate}

En el ejemplo siguiente pueden verse algunas de las distintas mutaciones que corresponden a las restricciones anteriores, en algunos casos el mismo mutante puede ser logrado por distintas mutaciones:
\begin{lstlisting}[mathescape=true]
  current = current.next; //original
  $\delta$current = header; //2x1
  $\delta$current = current; //2x1 o D 
  $\delta$current = current.next.next; //1x2 o A
  $\delta$current = header.previous.next; //1x2 o A
  previous = current; //original
  $\delta$previous = header; //R
  $\delta$previous = null; //R
  $\delta$previous = current.next; //1x2 o A
  $\delta$previous = header.next; //1x2
\end{lstlisting}

En las Figuras \ref{figures.code.prvoMethods.sameLength}, \ref{figures.code.prvoMethods.increaseLength}, \ref{figures.code.prvoMethods.decreaseLength}, \ref{figures.code.prvoMethods.twoByOne}, y \ref{figures.code.prvoMethods.oneByTwo}, se muestran versiones muy simplificadas de los m\'etodos de \emph{prvo} para generar mutaciones (reemplazo por literales por ejemplo no se muestra). M\'etodos auxiliares utilizados por \'estos incluyen a:

\begin{enumerate}[leftmargin=.75cm,align=left]
	\item[\textbf{generateMutant(Expression, Expression)}]\mbox{}\\ Este m\'etodo toma la expresi\'on original (primer par\'ametro) y la reemplaza por la expresi\'on mutada (segundo argumento).
	
	\item[\textbf{append(Expression...)}]\mbox{}\\ Este m\'etodo toma una secuencia de expresiones y las une mediante el operador de navegaci\'on (\emph{punto}), los argumentos nulos son ignorados.
	
	\item[\textbf{isReachable(Expression, Expression)}]\mbox{}\\ Este m\'etodo verifica si la primer expresi\'on es alcanzable desde la segunda, es decir, si el primer elemento de la primer expresi\'on representa un miembro del tipo del \'ultimo elemento de la segunda. Por ejemplo \emph{next.value} es alcanzable desde \emph{this.header} en una lista (ver Figura \ref{figures.examples.navegationExprGraph}).
	
	\item[\textbf{elements(Expression)}]\mbox{}\\ Retorna una lista de todos los elementos que conforman una expresi\'on con respecto al operador de navegaci\'on. Por ejemplo, la expresi\'on \emph{current.next.value} retorna\'ia una lista con \emph{current}, \emph{next}, y \emph{value}.
	
	\item[\textbf{getType(Expression)}]\mbox{}\\ Este m\'etodo retorna el tipo asociado al \'ultimo elemento de una expresi\'on. Por ejemplo, para la expresi\'on \emph{current.next} retornar\'ia \emph{Node} (ver Figura \ref{figures.examples.navegationExprGraph}).
	
	\item[\textbf{compatibleTypes(Type, Type)}]\mbox{}\\ Este m\'etodo verifica si el primer tipo es compatible con el segundo. La compatibilidad ser\'a verificada de acuerdo a la configuraci\'on de \emph{prvo}, si el chequeo de tipos es relajada, entonces se verifica si el primer tipo es asignable al segundo; si por el contrario se est\'a utilizando un chequeo de tipos estricto, entonces solo son compatibles los tipos iguales.
	
	\item[\textbf{fieldsAndMethodsFrom(Expression)}]\mbox{}\\ Retorna todos los miembros accesibles desde el \'ultimo elemento de una expresi\'on (no nula).
	
	\item[\textbf{reachableVarsFieldsAndMethods()}]\mbox{}\\ Retorna todas las variables, campos y m\'etodos que son alcanzables desde el punto actual.
	
	\item[\textbf{nextExpression(Expression)}]\mbox{}\\ Dada una expresi\'on retorna \emph{null} si la expresi\'on no estaba conectada mediante el operador de navegaci\'on o otra, y retorna la expresi\'on a la cual est\'a conectada mediante el operador de navegaci\'on en caso contrario. Cabe destacar que si bien el m\'etodo \emph{elements(Expression)} retorna elementos desconectados, \'estos tienen asociados a que expresiones estaban previamente conectados.
	
	\item[\textbf{previousExpression(Expression)}]\mbox{}\\ Equivalente a \emph{nextExpression(Expression)} pero retornando la expresi\'on a la cual \'esta estaba conectada (o \emph{null} si no lo estaba).
	
	\item[\textbf{lastExpressionFrom(Expression)}]\mbox{}\\ Retorna el \'ultimo elemento en una expresi\'on, el cual es o la misma expresi\'on original si \'esta no es de navegaci\'on, o el \'ultimo miembro en caso contrario. Por ejemplo \emph{lastExpressionFrom(current.next.value)} retornar\'ia \emph{value}.
\end{enumerate}

\begin{figure}
	\lstinputlisting[basicstyle=\small, language=Java, tabsize=3]{results/draft/PRVO_sameLength.java}
	\caption{M\'etodo de generaci\'on de mutantes de \emph{prvo} para generar expresiones donde el tama\~no de la misma se mantiene.}
	\label{figures.code.prvoMethods.sameLength}
\end{figure}

\begin{figure}
	\lstinputlisting[basicstyle=\small, language=Java, tabsize=3]{results/draft/PRVO_increaseLength.java}
	\caption{M\'etodo de generaci\'on de mutantes de \emph{prvo} para generar expresiones donde el tama\~no de la misma se incrementa a\~nadiendo un nuevo elemento a la expresi\'on.}
	\label{figures.code.prvoMethods.increaseLength}
\end{figure}

\begin{figure}
	\lstinputlisting[basicstyle=\small, language=Java, tabsize=3]{results/draft/PRVO_decreaseLength.java}
	\caption{M\'etodo de generaci\'on de mutantes de \emph{prvo} para generar expresiones donde el tama\~no de la misma se decrementa eliminando un elemento de la expresi\'on.}
	\label{figures.code.prvoMethods.decreaseLength}
\end{figure}

\begin{figure}
	\lstinputlisting[basicstyle=\small, language=Java, tabsize=3]{results/draft/PRVO_twoByOne.java}
	\caption{M\'etodo de generaci\'on de mutantes de \emph{prvo} para generar expresiones donde el tama\~no de la misma se decrementa reemplazando dos elementos de una expressi\'on por uno.}
	\label{figures.code.prvoMethods.twoByOne}
\end{figure}

\begin{figure}
	\lstinputlisting[basicstyle=\small, language=Java, tabsize=3]{results/draft/PRVO_oneByTwo.java}
	\caption{M\'etodo de generaci\'on de mutantes de \emph{prvo} para generar expresiones donde el tama\~no de la misma se incrementa reemplazando un elemento de una expressi\'on por dos.}
	\label{figures.code.prvoMethods.oneByTwo}
\end{figure}

\subsubsection{Restricciones de puntos de mutaci\'on}

El tipo de expresiones que muta \emph{prvo} puede encontrarse en una gran cantidad de lugares distintos en el c\'odigo fuente. Si bien en el ejemplo anterior las expresiones mutadas fueron siempre sobre asignaciones y solo se aplicaban mutaciones a la parte derecha de la misma, \emph{prvo} cuenta actualmente con las siguientes restricciones configurables:

\begin{enumerate}[leftmargin=.75cm,align=left]
	\item[\textbf{Parte izquierda de asignaciones}] En una asignaci\'on \texttt{a = b}, \emph{prvo} puede o no generar mutaciones para \texttt{a}. Es necesario destacar que estas mutaciones no se aplican en declaraciones de variables, es decir, expresiones \texttt{T a = b}, dado que modificar \texttt{a} en este caso tender\'ia a generar mutantes que no compilan. Si bien es cierto que existen fallas en donde un desarrollador puede olvidar declarar una variable local, y de esta forma hacer menci\'on a un atributo/campo de clase, este tipo de fallas no corresponde con las que se desea representar mediante \emph{prvo}.
	
	\item[\textbf{Parte derecha de asignaciones}] En una asignaci\'on \texttt{a = b}, \emph{prvo} puede o no generar mutaciones para \texttt{b}.
	
	\item[\textbf{Sentencias de retorno y expresiones internas}] El operador \emph{prvo} es capaz de mutar expresiones encadenadas asociadas a sentencias de retorno (\texttt{return e}), al mismo tiempo que expresiones unarias y binarias encontradas en asignaciones \texttt{(a = e \&\& f)}, en sentencias condicionales \texttt{(while(c) ...)}, argumentos de m\'etodos \texttt{foo(x)}, e incluso en las distintas partes de sentencias \texttt{for} como la inicializaci\'on, condici\'on e incremento.
\end{enumerate}

\subsubsection{Restricciones de expresiones a utilizar}

Incluso luego de configurar restricciones sobre cuanto disminuir o incrementar una expresi\'on, y en que partes del c\'odigo aplicar \emph{prvo}. La cantidad de expresiones v\'alidas disponibles para mutar la expresi\'on, sigue siendo demasiado grande. Esto trae aparejado problemas de eficiencia (la cantidad de mutantes afecta los recursos necesarios para mutation testing), generaci\'on de mutantes triviales o con poca dificultad para ser detectados, y mutantes redundantes.

La expresi\'on \lstinline|Object obj = current.next;|, puede dar lugar a una enorme cantidad de mutaciones v\'alidas, dado que no solo cualquier tipo no primitivo hereda de \texttt{Object}, sino que adem\'as, \emph{Java} permite ``autoboxing'' de tipos primitivos. Esta t\'ecnica permite que expresiones como \lstinline|Integer i = 1;| sean v\'alidas e internamente se traducen a \lstinline|Integer i = new Integer(1);|. Volviendo al ejemplo anterior podemos ver que es posible generar una gran cantidad de mutaciones completamente v\'alidas desde un punto de vista de tipos, pero completamente independientes de los tipos que pueden ser de inter\'es o que est\'an involucrados en la expresi\'on original. Ejemplos de \'estas son:
\begin{lstlisting}
  Object obj = current.toString();
  Object obj = current.getClass();
  Object obj = current.hashCode();
  Object obj = current.toString().length;
  Object obj = current.next.toString();
  ...
\end{lstlisting}

Por esto, \emph{prvo} cuenta con las siguientes restricciones configurables:

\begin{enumerate}[leftmargin=.75cm,align=left]
	\item[\textbf{M\'etodos y campos restringidos}] Es posible definir expresiones regulares para restringir el uso de ciertos m\'etodos y campos, por ejemplo:
	\begin{lstlisting}[mathescape=true]
	java\\.lang\\.String\\$\#$.*
	\end{lstlisting}
	restringe cualquier m\'etodo y campo de \emph{java.lang.String}. Durante la generaci\'on de mutaciones, \emph{prvo} verifica que cualquier m\'etodo o campo que vaya a utilizar para mutar una expresi\'on encadenada, no est\'e restringida, la verificaci\'on se hace sobre el nombre completo de un miembro de clase, el cual se define con \emph{<nombre completo de la clase>\#<nombre del miembro>[(<tipos de los argumentos separados por coma>)]} por ejemplo \emph{java.lang.String\#substring(int, int)}.
	
	\item[\textbf{M\'etodos y campos permitidos}] En muchos casos, la cantidad de m\'etodos y campos a restringir es muy grande y solo se quieren permitir aquellos que pertenezcan a ciertas clases, por ejemplo, en el caso de una lista puede solo desearse utilizar aquellos que pertenezcan a la clase \emph{Lista} y \emph{Nodo}. Es posible definir, de la misma forma que en el caso anterior, que m\'etodos y campos son permitidos para que \emph{prvo} los utilice durante la generaci\'on de mutaciones. Cabe destacar que estas opciones son exclusivas, no es posible utilizar ambas al mismo tiempo.
	
	\item[\textbf{Control de tipos}] En lenguajes orientados a objetos como \emph{Java}, la herencia de clases permite que dos tipos sean compatibles a\'un cuando no son iguales. Dados dos tipos, \texttt{A} y \texttt{B}, tal que el segundo hereda del primero. La asignaci\'on \lstinline|A a = new B();| es v\'alida mientras que la inversa no lo es. Una expresi\'on encadenada mutada por \emph{prvo} tiene que ser correcta con respecto a tipos, pero con esto podemos cambiar expresiones como \lstinline|list.node.value| a \lstinline|list.toString().getClass()| si \texttt{value} era de tipo \texttt{Object}. Por esto, \emph{prvo} puede restringirse a utilizar un control estricto de tipos, en donde \'estos solo se consideran compatibles sin son exactamente iguales.
	
	\item[\textbf{Uso de literales}] En ciertos casos el uso de literales conforman expresiones v\'alidas para mutar una expresi\'on, \lstinline|var.toString().length| puede cambiarse a \lstinline|"".length|. Cualquier operador que utilice valores literales, va a requerir un conjunto finito de los mismos. En el caso de \emph{prvo}, utiliza un conjunto de literales base, \emph{1, 0, True, False, "", null} en donde cada uno puede habilitarse o no; a su vez permite la b\'usqueda de literales alcanzables desde el punto en donde se est\'a mutando; tambi\'en es posible habilitar/deshabilitar la generaci\'on de variaciones en literales num\'ericos, es decir que para cada literal que pertenezca a un tipo primitivo num\'erico, se van a crear copias del mismo para los otros tipos. Por ejemplo, para \texttt{2}, un literal de tipo \texttt{int} se van a crear las variantes \texttt{2.0d}, \texttt{2.0f}, y \texttt{2l}, de tipos \emph{double}, \emph{float}, y \emph{long} respectivamente.
	
	\item[\textbf{Uso de campos est\'aticos}] El modificador \emph{static} en \emph{Java} define a un miembro que es compartido por todas las instancias de la clase que lo define. Estos miembros est\'aticos no deber\'ian accederse mediante instancias de una clase, aunque hacerlo es posible y no representa c\'odigo inv\'alido. Sin embargo si \'esto se permite, se pueden obtener muchas mutaciones asociadas al uso de constantes est\'aticas que no fueron restringidas mediante otra configuraci\'on. Por eso, \emph{prvo} permite la restricci\'on del uso de miembros est\'aticos en un contexto no est\'atico.
\end{enumerate}

\section{Dynamic mutant subsumption}
\label{sec:implementation.dynamicSubsumption}

El uso de \emph{mutation score}, la relaci\'on de mutantes detectados sobre el total, como m\'etrica de evaluaci\'on para test suites, trae varios problemas sobre que conclusiones se pueden derivar del mismo. Entre \'estos, hemos mencionado el detectar mutantes triviales, incrementando el valor de mutation score sin implicar una mejora en la capacidad de detectar fallas de la test suite; la existencia de mutantes que son sem\'anticamente equivalentes al programa original, y por lo tanto imposibles de detectar, bajando el valor del mutation score sin significar una menor capacidad de detectar fallas; finalmente el acoplamiento, es decir, que tan bien los mutantes representan fallas reales, y los mutantes redundantes. Estos problemas hacen que el an\'alisis de \emph{mutation testing} requiera cuidado al interpretar los resultados, y estudios m\'as profundos para dar mayor validez a los mismos. Estos estudios a\~naden complejidad al an\'alisis y, en la mayor\'ia de los casos, requiere resolver problemas indecidibles o altamente complejos. Particularmente, como la meta de este trabajo es evaluar un nuevo operador de mutaci\'on, cuan significativo es el valor de mutation score se torna a\'un m\'as importancia. Al mismo tiempo, si bien analizar cuantos mutantes equivalentes genera \emph{prvo} solo muestra una parte de los resultados, siendo posible tener un operador que no genere mutantes equivalentes pero que \'estos sean altamente redundantes con respecto a los producidos con otros operadores (o incluso redundantes entre mutantes de \emph{prvo}). La utilizaci\'on de \'este an\'alisis (\emph{Dynamic Mutant Subsumption}) es entonces una buena forma de evaluar la utilidad de los mutantes generados por \emph{prvo} con respecto a su capacidad para evaluar tests.
Recordemos primero la definici\'on de \emph{Mutant Subsumption} antes de discutir sobre la m\'as acotada definici\'on de \emph{Dynamic Mutant Subsumption}.
\begin{quote}
	Para dos mutantes \emph{m$_1$} y \emph{m$_2$}, producidos a partir del programa original \emph{p}. Se define la relaci\'on \emph{m$_1$} subsume a \emph{m$_2$}, si existe al menos un test para el cual el comportamiento de \emph{m$_1$} difiera del de \emph{p}, y para todo test \emph{t} para el cual el comportamiento entre \emph{m$_1$} y \emph{p} difiera, el comportamiento entre \emph{m$_2$} y \emph{p} tambi\'en debe hacerlo.
\end{quote}
Un punto importante es que la definici\'on anterior habla del universo de tests, todo test posible, lo cual hace de \emph{Mutant Subsumption}, un problema indecidible salvo para casos triviales, es decir, problemas con un conjunto finito de posibles escenarios. De todas formas, es posible una resoluci\'on acotada a este problema. Antes de pasar a la implementaci\'on de este an\'alisis, es necesario mostrar cual es la utilidad del mismo.
La intuici\'on es que si un mutante es detectado por una gran cantidad de tests mientras otros son detectados por subconjuntos que detectan al primero, entonces detectar cualquiera de \'estos lleva a detectar tambi\'en al primero, evaluando varias veces los mismos tests. Por otro lado, un mutante que requiere tests m\'as espec\'ificos para ser detectado genera un mejor ``feedback'' sobre los tests, que uno que es detectado por casi cualquiera. Como mencionamos, en la pr\'actica no es posible hacer un an\'alisis basado en la definici\'on anterior, por lo que la siguiente definici\'on es utilizada.
\begin{quote}
	Para dos mutantes \emph{m$_1$} y \emph{m$_2$}, producidos a partir del programa original \emph{p}, y un conjunto de tests \emph{T}. Se define la relaci\'on \emph{m$_1$} subsume din\'amicamente a \emph{m$_2$}, si existe al menos un test en \emph{T} para el cual el comportamiento de \emph{m$_1$} difiera del de \emph{p}, y para todo test \emph{t} en \emph{T} para el cual el comportamiento entre \emph{m$_1$} y \emph{p} difiera, el comportamiento entre \emph{m$_2$} y \emph{p} tambi\'en debe hacerlo.
\end{quote}
Esta definici\'on da a lugar a \emph{Dynamic Mutant Subsumption}, y es la que se implement\'o en \emph{$\mu$Java++} y que va a ser utilizada como evaluaci\'on adicional, en este caso para el conjunto de mutantes generados en cada experimento.

\subsection{Dynamic Mutant Subsumption Graph}
\label{sec:implementation.dynamicSubsumption.graph}

A partir del an\'alisis anterior, es posible construir un grafo en el cual un nodo contiene todos los mutantes equivalentes respecto a subsuma, es decir, para cada par de nodos \emph{m$_1$} y \emph{m$_2$} en el nodo, \emph{m$_1$} subsume a \emph{m$_2$} y viceversa. Una arista direccional conectando el nodo \emph{n$_1$} con el nodo \emph{n$_2$} representa la relaci\'on de subsuma:
\begin{quote}
	Para cada mutante \emph{m$_i$} en el nodo \emph{n$_1$}, y para cada mutante \emph{m$_j$} en el nodo \emph{n$_2$}, se cumple que \emph{m$_i$} subsume a \emph{m$_j$}.
\end{quote}
Un ejemplo de la generaci\'on de estos grafos se puede ver comenzando con la Tabla \ref{tables.examples.subsumptionInit} la cual es generada al final del an\'alisis de mutation testing, cada mutante analizado se almacena en un nodo \'unico con la informaci\'on de que tests detectaron al mismo. A partir de estos datos se eliminan los nodos que corresponden a mutantes que sobrevivieron (recordemos que la primer condici\'on para la relaci\'on de subsuma es que los mutantes en la relaci\'on hayan sido detectados) y todos los nodos que corresponden a mutantes detectados por los mismos tests, es decir, se subsumen el uno al otro, se fusionan en un mismo nodo, \'esto se puede apreciar en la Tabla \ref{tables.examples.subsumptionEquivAndKilled} donde por ejemplo el nodo \textbf{4} fue eliminado, el nodo \textbf{7} fue fusionado con el nodo \textbf{2} y lo mismo ocurri\'o con los nodos \textbf{3} y \textbf{5}. A partir de la \'ultima tabla (o a partir de los nodos representados en la misma) se puede construir el grafo de subsuma din\'amica de la Figura \ref{figures.examples.dynamicSubsumptionGraph}.
A partir de este grafo se observan nodos que son subsumidos pero no subsumen a nadie, a los mutantes en estos nodos se los considera los m\'as redundantes de todos. Nodos que subsumen a otros y son a su vez subsumidos, \'estos siguen siendo redundantes pero en un grado menor a los anteriores. Finalmente los nodos que subsumen a otros pero no son a su vez subsumidos, son denominados ``dominadores''. Dado que en esta tesis presentamos una familia particular de operadores, y que son el objetivos de nuestra evaluaciones, lograr que los mutantes generados por \emph{prvo} ocupen una mayor\'ia de los nodos dominadores, no alcanza, \'esto es causa de que cualquier mutante generado por otro operador e inclu\'ido en el nodo, es equivalente a los de \emph{prvo}. Este problema se extiende a la evaluaci\'on de cualquier operador utilizando grafos de dynamic mutant subsumtion. Por esto, este an\'alisis incluye la propiedad de pureza en los nodos.
\begin{quote}
	Un nodo en un grafo de dynamic mutant subsumption es considerado puro, si para cada mutante contenido en el mismo, \'este fue generado por el mismo operador.
\end{quote}
En la pr\'actica \'estos grafos son impr\'acticos de utilizar por ser demasiado grandes como para poder extraer informaci\'on del mismo. Sin embargo la estructura de grafos permite f\'acilmente definir los conceptos de nodos dominadores y redundantes.
Una clara desventaja de este an\'alisis es que requiere ejecutar todos los tests por cada mutante, contrariamente al an\'alisis b\'asico de mutation testing (cuando solo interesa obtener el valor de mutation score) que solo se ejecutan todos los tests para un mutante para aquellos que sobreviven, pero solo siendo necesario ejecutar los tests hasta encontrar el primero que detecta al mutante en los casos donde \'este no sobrevive.

\begin{table}[]
	\begin{tabular}{|cccccccc|}
		\hline
		Node & Mutants & Test1 & Test2 & Test3 & Test4 & Test5 & Test6 \\ \hline
		1 & m1 & $\bullet$ &  & $\bullet$ & $\bullet$ &  & $\bullet$ \\ \hline
		2 & m2 & $\bullet$ &  & $\bullet$ &  &  &  \\ \hline
		3 & m3 & $\bullet$ & $\bullet$ & $\bullet$ &  &  &  \\ \hline
		4 & m4 &  &  &  &  &  &  \\ \hline
		5 & m5 & $\bullet$ & $\bullet$ & $\bullet$ &  &  &  \\ \hline
		6 & m6 & $\bullet$ &  &  & $\bullet$ &  & $\bullet$ \\ \hline
		7 & m7 & $\bullet$ &  & $\bullet$ &  &  &  \\ \hline
		8 & m8 &  &  & $\bullet$ &  &  &  \\ \hline
	\end{tabular}
	\caption{Nodos iniciales con un solo mutante asociado y los tests que detectan al mismo.}
	\label{tables.examples.subsumptionInit}
\end{table}

\begin{table}[]
	\begin{tabular}{|cccccccc|}
		\hline
		Node & Mutants & Test1 & Test2 & Test3 & Test4 & Test5 & Test6 \\ \hline
		1 & m1 & $\bullet$ &  & $\bullet$ & $\bullet$ &  & $\bullet$ \\ \hline
		2 & m2, m7 & $\bullet$ &  & $\bullet$ &  &  &  \\ \hline
		3 & m3, m5 & $\bullet$ & $\bullet$ & $\bullet$ &  &  &  \\ \hline
		6 & m6 & $\bullet$ &  &  & $\bullet$ &  & $\bullet$ \\ \hline
		8 & m8 &  &  & $\bullet$ &  &  &  \\ \hline
	\end{tabular}
	\caption{Nodos equivalentes fusionados y nodos que representan mutantes sobrevivientes eliminados.}
	\label{tables.examples.subsumptionEquivAndKilled}
\end{table}

\begin{figure}
	\begin{center}
		\usetikzlibrary{positioning}
		\begin{tikzpicture}%
		[>=stealth,
		shorten >=1pt,
		node distance=3cm,
		on grid,
		auto,
		every state/.style={draw=black!60, fill=black!5, very thick}
		]
		\tikzstyle{v}=[circle, minimum size=1mm,draw,thick]
		\node[v, label=above: {\small 1}] (n1) {m1};
		\node[v, label=above: {\small 2}] (n2)[above=of n1] {m2,m7};
		\node[v, label=above: {\small 3}] (n3)[right=of n1] {m3,m5};
		\node[v, label=above: {\small 6}] (n6)[right=of n2] {m6};
		\node[v, label=above: {\small 8}] (n8)[right=of n6] {m8};
		
		\path[->]
%		%   FROM  BEND/LOOP  POSITION OF LABEL   LABEL   TO
		(n8) edge (n1)
		(n8) edge[bend right=40] (n2)
		(n8) edge (n3)
		(n2) edge (n3)
		(n2) edge[bend right=30] (n1)
		(n6) edge (n1)
		;
		\end{tikzpicture}
	\end{center}
	\caption{Grafo de \emph{Dynamic Mutant Subsumption} generado mediante la informaci\'on de la Tabla \ref{tables.examples.subsumptionEquivAndKilled}}
	\label{figures.examples.dynamicSubsumptionGraph}
\end{figure}