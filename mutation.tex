\chapter[Mutation]{Mutation testing}
\label{sec:preliminares.mutation}

\emph{Mutation testing} es un criterio de cobertura que puede ser considerado de \emph{caja blanca}, en donde las metas a cubrir por el test suite est\'an representadas por fallas artificiales que deben ser detectadas por el test suite bajo evaluaci\'on. Las fallas artificiales se representan por variantes del programa original, en donde cada una tiene un cambio sint\'actico simple representando un defecto. Cada variante se denomina \emph{mutante}, mientras que la falla artificial asociada, \emph{mutaci\'on}.

Las fallas artificiales utilizadas por este criterio, se agrupan en operadores de mutaci\'on, por ejemplo, el operador de \emph{reemplazo de operadores relacionales} (\emph{ROR}) agrupa las fallas artificiales que cambian un operador relacional en una expresi\'on binaria por todos los otros disponibles en el lenguaje con el que est\'a escrito el programa.

\emph{Mutation score} es el valor asociado a este criterio, si bien la relaci\'on entre metas cubiertas y las generadas es el resultado asociado a cualquier criterio, para facilitar la referencia al resultado de este criterio, se utiliza este t\'ermino. Como con cualquier criterio, mientras mas cercano al 100\% sea \'este valor, m\'as confianza se puede tener en la calidad del test suite evaluado. En el caso de mutation testing, este valor sube mientras m\'as mutantes sean detectados y baja en caso contrario, sin embargo existen situaciones que afectan de manera negativa a este valor. Ciertas fallas son triviales de detectar, ya seapor que causan que la compilaci\'on o la ejecuci\'on (bajo cualquier entrada) falle, o solo requieren alcanzabilidad para hacerlo, por ejemplo \lstinline|if (c) x = array[-1];|. Las fallas triviales aumentan el mutation score sin implicar una mejora en la calidad del test suite. En el espectro opuesto, pueden haber fallas artificiales que tengan el mismo comportamiento sem\'antico, por ejemplo \lstinline|for (int i = 0; i < 10; i++)| es equivalente a \lstinline|for (int i = 0; i < 10; ++i)|. Estos mutantes son llamados equivalentes y por lo tanto indistinguibles del programa original, lo que genera metas que no pueden ser cubiertas, que a su vez disminuye el valor de mutation score, pero el test suite no tiene una peor calidad por no ser capaz de detectar estos mutantes. Finalmente un valor alto de mutation score no significa nada si no existe una relaci\'on entre detectar fallas artificiales y reales.

\section{Evaluaci\'on de operadores}

Las propiedades de inter\'es en el disen\~no  de operadores involucrados en mutation testing son, equivalencia de mutantes con el programa original y entre mutantes, dificultad de detecci\'on de mutantes, acoplamiento entre fallas reales y mutantes, y acoplamiento entre mutantes.

\subsection{Equivalencia}
Equivalencia [entre dos programas] es una propiedad definida bajo la relaci\'on \texttt{Eq(P, P$\prime$) : $\nexists$ E : P(E) != P$\prime$(E)}, la cual establece que dos programas \texttt{P} y \texttt{P$\prime$} son equivalente si no existe un escenario \texttt{E} tal que el comportamiento de ambos programas se distinto. Esta es una relaci\'on indecidible por lo que m\'etodos incompletos son utilizados. Dentro de mutation testing, equivalencia puede encontrarse entre un mutante y el programa original, un caso indeseable ya que \'estos disminuyen el valor del mutation score sin significar una deficiencia de parte del test suite en detectar ciertas fallas artificiales. Otro caso de equivalencia se da entre mutantes, un caso en donde ambos mutantes son detectados por el test suite, sin embargo al ser equivalente incrementan el valor del mutation score sin significar una mejora de parte del test suite en detectar m\'as fallas artificiales.

Dentro de la investigaci\'on sobre la detecci\'on (evaluaci\'on) de esta caracter\'istica y su impacto en el ana\'alisis de test suites usando mutation testing, \cite{biblography.mutation.evaluation.equivalent.Schuler+10} propone la utilizaci\'on de diferencia en cobertura de c\'odigo y an\'alisis de fujo de datos para determinar potencial equivalencia. Mientras que  \cite{biblography.mutation.evaluation.equivalent.Just+13} utiliza detecci\'on de restricciones condicionales para alcanzar el c\'odigo mutado y \emph{SAT Solving} para determinar si es posible satisfacer dichas restricciones al tiempo que se obtiene un valor distinto al del programa original en ese punto, lo que es similar en principio a \emph{weak mutation}, en donde se considera que un mutante es detectado si en el estado siguiente a la mutaci\'on se detecta una diferencia con el del programa original, pero a\~nadiendo control de alcanzabilidad y una verificaci\'on exhaustiva acotada para detectar si es posible que exista una diferencia.
En \cite{biblography.mutation.evaluation.equivalent.Grun+09} observan que manualmente, para los casos de estudios utilizados, un programador avanzado tarda aproximadamente 15 minutos en promedio para analizar mutantes equivalentes. Y claramente la existencia de equivalentes disminuye artificialmente el mutation score dando la falsa impresi\'on de que es necesario agregar m\'as tests.

\subsection{Dificultad de detecci\'on}

As\'i como los mutantes equivalentes son indeseables por ser imposibles de detectar, los mutantes que son solo detectables por un conjunto peque\~no de tests, son altamente deseables. Estos son denominados \emph{stubborn} \cite{bibliography.mutation.evaluation.stubbornHieronsHD99}. La detecci\'on de estos mutantes requieren tests de "mejor calidad" y si bien existen estudios que eval\'uan la generaci\'on de stubborns por operador \cite{bibliography.mutation.evaluation.stubborn}, \'este depende del conjunto de programas utilizados y los tests asociados. Con respecto a este obst\'aculo, en \cite{bibliography.mutation.evaluation.hardnessVisser}, proponen el uso de \emph{model counting} sobre programas m\'as simples pero utilizando un estudio m\'as exhaustivo.

\subsection{Subsunci\'on}

\emph{Subsumption}, la relaci\'on entre mutantes con respecto a los tests que los detectan, dan lugar a mutantes redundantes. Esto es, los tests que detectan al mutante subsumido, incluyen a aquellos que detectan al que subsume, es decir, el mutante subsumido eval\'ua de manera menos espec\'ifica a los tests ya que es detectado por una mayor cantidad, mientras que el que subsume eval\'ua tests m\'as espec\'ificos. Esto lleva a mutantes redundantes y representa una forma de evaluar la dificultad de detecci\'on, los mutantes que subsumen a otros pero no son a su vez subsumidos, son detectados por pocos tests. Presentado inicialmente en \cite{bibliography.mutation.selection.Offutt96}, mutant subsumption es utilizado por \cite{bibliography.mutation.minimizing.dynamicsubsumption} y \cite{bibliography.mutation.evaluation.JustKA17} para evaluar utilidad de mutantes dentro de mutation analysis.

\subsection{Acoplamiento}

\emph{Coupling}, el acoplamiento entre fallas reales y mutantes es una propiedad altamente deseable, sin la misma, mutation testing perder\'ia su utilidad al desaparecer la correlaci\'on entre un mutation score alto y una buena capacidad de parte del test suite para detectar fallas reales. El trabajo m\'as importante sobre este tema, y uno que nos representa una motivaci\'on importante para el desarrollo de nuestros operadores de mutaci\'on presentados en esta tesis, es \cite{bibliography.mutation.evaluation.valid-substitute}. El acoplamiento entre mutantes y fallas reales es una relaci\'on que especifica que si un conjunto de tests detecta un conjunto de mutantes, entonces va a detectar una falla real. 

\section{High order}

\texttt{High Order}, la combinaci\'on de mutaciones, generada al aplicar operadores de mutaci\'on m\'as de una vez al generar un mutante, se denominan mutaciones de alto order mientras que aquellas que la forman, se las llama de primer orden. Si bien en principio esto agregar\'ia una gran cantidad de nuevos mutantes\footnote{Usualmente la cantidad de mutantes al aplicar m\'as de una mutaci\'on por mutante est\'a acotada por M$_0^G$ en donde \texttt{M$_0$} son la cantidad de mutantes de primer orden y \texttt{G} son la cantidad de mutaciones por mutante}, los estudios actuales que se enfocan en esta t\'ecnica concluyen que estos mutantes de alto orden representan fallas artificiales m\'as sutiles y que subsumen a una gran cantidad de mutantes de primer orden. [AGREGAR]