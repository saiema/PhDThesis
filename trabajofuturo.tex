%!TEX root = main.tex
\chapter[Trabajo futuro]{Trabajo futuro}
\label{cap:futurework}

El trabajo presentado en esta tesis abre algunas l\'ineas de trabajo futuro. Por un lado, planeamos analizar m\'as profundamente cuales de las clases de fallas no acopladas a operadores actuales, identificadas en la secci\'on \ref{sec:prvo.prvoTargetedFaults}, est\'an acopladas a \emph{prvo}. Creemos que algunas est\'an directamente cubiertas por nuestro operador. Actualmente un estudio sobre este posible acoplamiento est\'a siendo realizado como parte del trabajo final de Licenciatura en Ciencias de la Computaci\'on de un alumno de la Universidad Nacional de R\'io Cuarto bajo la direcci\'on de Pablo Ponzio y m\'ia, \'este est\'a basado en el trabajo realizado por Ren\'e Just \cite{bibliography.mutation.evaluation.valid-substitute} e intenta encontrar si existe un acoplamiento de \emph{prvo} a fallas a\'un no acopladas en ese trabajo, en particular a aquellas mencionadas en \ref{sec:prvo.prvoTargetedFaults}.

Nuestro operador \emph{prvo} se presenta como un ``meta-operador'' altamente configurable, donde cada configuraci\'on se puede ver como un operador particular. La configuraci\'on del mismo se hace, en este trabajo, de una manera manual. C\'omo automatizar esta configuraci\'on bas\'andose en caracter\'isticas del programa al cual est\'a siendo aplicado, forma parte de un camino de investigaci\'on a explorar.

En esta tesis se utiliz\'o \emph{Dynamic Mutant Subsumption} como uno de los an\'alisis principales para evaluar el desempe\~no de \emph{prvo} en el contexto de mutation testing. Dentro de \'este, las nociones de mutantes dominantes y mutantes dominantes puros fueron las de mayor importancia para determinar si \emph{prvo} pod\'ia considerarse dentro de los operadores suficientes o si por el contrario generaba mutantes redundantes. Afortunadamente los resultados indican que esto \'ultimo no sucede y los mutantes de \emph{prvo}, al menos dentro de los casos de estudio utilizados, tienden a ser dominantes. Un futuro an\'alisis sobre cuales son los operadores cuyos mutantes \emph{prvo} tiende a dominar, podr\'ia permitir decidir a cuales de \'estos es posible reemplazar con \emph{prvo}. A su vez, creemos que, tal como se expuso en \ref{sec:preliminares.mutation.whysubsumption}, Dynamic Mutant Subsumption representa una m\'etrica m\'as confiable que \emph{Mutation Score} y \emph{Toughness} como forma de evaluar operadores de mutaci\'on y/o t\'ecnicas de selecci\'on de mutantes. \'Esta es solo una intuici\'on que requerir\'ia mayores experimentos y an\'alisis, pero que sin embargo creemos que podr\'ia beneficiar a estudios futuros. 

\section{PRVO en reparaci\'on autom\'atica de programas}

Como mencionamos en el cap\'itulo \ref{cap:repair}, la reparaci\'on autom\'atica de programas utilizando mutaci\'on, es un \'area de investigaci\'on activa y en donde se debe balancear la capacidad de reparaci\'on, es decir, el conjunto de defectos que pueden ser reparados y la cantidad de sentencias que pueden estar involucradas en la reparaci\'on, con los recursos necesarios para encontrar a la misma. As\'i como nuestra motivaci\'on para proponer a \emph{prvo} como un operador a ser utilizado en \emph{mutation testing}, se basa principalmente en cuan extenso es el uso de expresiones de navegaci\'on en programas orientados a objetos, la misma puede aplicarse para motivar a \emph{prvo} como un operador a ser utilizado en la reparaci\'on de programas orientados a objetos. En la secci\'on \ref{sec:repair.striker.evaluation} se presentan algunos resultados que es capaz de conseguir \emph{Stryker} en cuanto a reparaci\'on de m\'ultiples defectos junto con el uso de una gran cantidad de operadores de mutaci\'on. La gran flexibilidad provista por \emph{prvo}, principalmente en cuanto a acotar las expresiones a utilizar, podr\'ia ser explotada para diminuir considerablemente el espacio de candidatos a reparaci\'on con respecto a los generados por este operador. La relaci\'on entre restricciones a la configuraci\'on de \emph{prvo} con respecto a las expresiones a utilizar, los potenciales beneficios (menor espacio de b\'usqueda), y desventajas (la perdida de la capacidad de reparar ciertos defectos), representa una investigaci\'on muy interesante en el \'area de reparaci\'on autom\'atica de programas.

\pagebreak
\section{Mutaciones guiadas}

Tanto en reparaci\'on como en mutation testing, la flexibilidad de \emph{prvo} gracias a la amplia gama de configuraciones, permite maximizar la utilidad de los mutantes generados con respecto a la cantidad. Sin embargo, la configuraci\'on es est\'atica y definida por el usuario previo a ejecutar el proceso de mutation testing o reparaci\'on. Cierta informaci\'on disponible mediante an\'alisis est\'atico (como obtenci\'on de condiciones de camino mediante ejecuci\'on simb\'olica) o informaci\'on disponible en tiempo de ejecuci\'on (como el estado del heap) podr\'ian ser explotados para realizar un ajuste mucho m\'as fino sobre los mutantes generados por \emph{prvo}. Consideremos el siguiente c\'odigo:
\begin{lstlisting}[frame=single, numbers=left, mathescape=true,language=Java,basicstyle={},framexleftmargin=.073\textwidth,xleftmargin=.085\textwidth,xrightmargin=0.012\textwidth]
  ...
  if (current.next == null) {
    current.next = new Node(value);
  } else {
    ...
  }
  ...
\end{lstlisting}
En la l\'inea $3$, mutar \texttt{current.next} a \texttt{current.next.next} resulta en un mutante trivial de detectar (solo es necesario un test que ejecute la sentencia), con la informaci\'on provista por un an\'alisis de condiciones de caminos, el conocimiento de que en la l\'inea $3$ \texttt{current.next} es \texttt{null} podr\'ia ser utilizado para localmente restringir el uso del campo \texttt{next} para extender a la expresi\'on \texttt{current.next}.
En el contexto de reparaci\'on, el uso de contratos podr\'ia ser explotado de la misma forma para guiar qu\'e mutantes generar mediante \emph{prvo}.