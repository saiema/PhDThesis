%!TEX root = main.tex
\chapter[Trabajo futuro]{Trabajo futuro}
\label{cap:futurework}

El trabajo presentado en esta tesis abre algunas l\'ineas de trabajo futuro. Por un lado, planeamos analizar m\'as profundamente cuales de las clases de fallas no acopladas a operadores actuales, identificadas en la secci\'on \ref{sec:prvo.prvoTargetedFaults}, est\'an acopladas a \emph{prvo}. Creemos que algunas est\'an directamente cubiertas por nuestro operador. Actualmente un estudio sobre este posible acoplamiento est\'a siendo realizado como parte del trabajo final de Licenciado en Ciencias de la Computaci\'on de un alumno de la Universidad Nacional de R\'io Cuarto bajo la direcci\'on de Pablo Ponzio y m\'ia, \'este est\'a basado en el trabajo realizado por Ren\'e Just \cite{bibliography.mutation.evaluation.valid-substitute} e intenta encontrar si existe un acoplamiento de \emph{prvo} a fallas a\'un no acopladas en ese trabajo, en particular a aquellas mencionadas en \ref{sec:prvo.prvoTargetedFaults}.

Nuestro operador \emph{prvo} se presenta como un ``meta-operador'' altamente configurable, donde cada configuraci\'on se puede ver como un operador particular. La configuraci\'on del mismo se hace, en este trabajo, de una manera manual. Como automatizar esta configuraci\'on bas\'andose en caracter\'isticas del programa al cual est\'a siendo aplicado, forma parte de un camino de investigaci\'on a explorar.

En esta tesis se utiliz\'o \emph{Dynamic Mutant Subsumption} como una de los an\'alisis principales para evaluar el desempe\~no de \emph{prvo} en el contexto de mutation testing. Dentro de \'este, las nociones de mutante dominador y mutantes dominadores puros fueron las de mayor importancia para determinar si \emph{prvo} pod\'ia considerarse dentro de los operadores suficientes o si por el contrario generaba mutantes redundantes. Afortunadamente los resultados indican que esto no sucede y los mutantes de \emph{prvo}, al menos dentro de los casos de estudio utilizados, genera mutantes que tienden a ser dominadores. Un futuro an\'alisis sobre cuales son los operadores cuyos mutantes \emph{prvo} tiende a dominar, podr\'ia permitir decidir a cuales de \'estos es posible reemplazar con \emph{prvo}. A su vez, creemos que, tal como se expuso en \ref{sec:preliminares.mutation.whysubsumption}, Dynamic Mutant Subsumption representa una m\'etrica m\'as confiable que \emph{Mutation Score} y \emph{Toughness} como forma de evaluar operadores de mutaci\'on y/o t\'ecnicas de selecci\'on de mutantes. \'Esta es solo una intuici\'on que requerir\'ia mayores experimentos y an\'alisis, pero que sin embargo creemos que podr\'ia beneficiar a estudios futuros. 

\section{PRVO en reparaci\'on autom\'atica de programas}

Como mencionamos en \ref{cap:repair}, reparaci\'on autom\'atica de programas utilizando mutaci\'on, es un \'area de investigaci\'on activa y en donde se debe balancear la capacidad de reparaci\'on, es decir, el conjunto de defectos que se pueden reparar y la cantidad de sentencias que pueden estar involucradas en la reparaci\'on, con los recursos necesario para encontrar a la misma. As\'i como nuestra motivaci\'on para proponer a \emph{prvo} como un operador a ser utilizado en \emph{mutation testing}, se basa principalmente en cuan extenso es el uso de expresiones de navegaci\'on en programas orientados a objetos, la misma puede aplicarse para motivar a \emph{prvo} como un operador a ser utilizado en la reparaci\'on de programas orientas a objetos. En la secci\'on \ref{sec:repair.striker.evaluation} se presentan algunos resultados que es capaz de conseguir \emph{Stryker} en cuanto a reparaci\'on de m\'ultiples defectos junto con el uso de una gran cantidad de operadores de mutaci\'on. La gran flexibilidad provista por \emph{prvo}, principalmente en cuanto a acotar las expresiones a utilizar, podr\'ia ser explotada para diminuir considerablemente el espacio de candidatos a reparaci\'on con respecto a los generados por este operador. La relaci\'on entre restricciones a la configuraci\'on de \emph{prvo} con respecto a las expresiones a utilizar, los potenciales beneficios (menor espacio de b\'usqueda), y desventajas (la perdida de la capacidad de reparar ciertos defectos), representa una investigaci\'on muy interesante en el \'area de reparaci\'on autom\'atica de programas.

%Junto a Frias, Luciano, Naza, etc, hemos trabajado en la herramienta llamada \emph{Striker}, presentada en \ref{sec:repair.striker}, la cual utiliza \emph{prvo} como uno de los operadores de mutaci\'on para la generaci\'on de candidatos a reparar un programa. Hemos observado numerosos casos en donde el uso de \emph{prvo} permite la reparaci\'on de fallas, que de otra forma, no podr\'ian ser encontradas. [AGREGAR CASOS EN QUE PRVO REPARA]