%!TEX root = main.tex
\chapter[Conclusiones]{Conclusiones}
\label{cap:conclutions}

Medir la calidad de un conjunto de tests evaluando su habilidad de detectar fallas artificiales, tal como propone \emph{mutation testing}, ha demostrado ser una de las m\'etricas m\'as efectivas en testing, brindando una mejor correlaci\'on, que otras m\'etricas, con detecci\'on de fallas reales. Sin embargo, algunas limitaciones importantes han sido identificadas en relaci\'on a mutaci\'on, m\'as notablemente la inhabilidad de operadores de mutaci\'on actuales en representar ciertos defectos reales en programas, y los problemas de eficiencia asociados con medir la calidad de una test suite, mediante an\'alisis de mutaci\'on. En esta tesis, hemos contribu\'ido a la primera de estas limitaciones, proveyendo un nuevo operador de mutaci\'on que aplica a expresiones com\'unmente encontradas en programas orientados a objetos, espec\'ificamente \emph{expresiones de navegaci\'on}. Hemos provisto de motivaciones para el dise\~no de este operador, al cual llamamos \emph{PRVO}, y hemos realizado un an\'alisis que nos permiti\'o mostrar que este operador no es subsumido por operadores existentes, es decir, no genera mutantes redundantes, y a su vez genera mutantes que constituyen nuevas ``obligaciones'' para las test suites, dentro de mutation testing. Adem\'as, nuestro an\'alisis muestra que, en presencia de \emph{PRVO}, el grado de dominancia de otros operadores disminuye mientras que la dominancia de los mutantes de \emph{PRVO} es comparable con la de varios de los operadores mas relevantes dentro de los \emph{operadores suficientes}. Tambi\'en analizamos el impacto de \emph{PRVO} en la eficiencia de an\'alisis de mutaci\'on, al evaluar el incremento en los mutantes generados que implica el a\~nadido de \emph{PRVO} al conjunto de operadores a utilizar. Nuestros resultados para este caso van desde casos de estudio para los cuales los mutantes adicionales representan un peque\~no porcentaje sobre los generados por operadores tradicionales, a casos en donde \emph{PRVO} genera un incremento del doble en la cantidad original de mutantes, siendo estos \'ultimos, casos excepcionales.

Con respecto a reparaci\'on autom\'atica de programas, en la secci\'on \ref{sec:repair.striker} presentamos a \emph{Stryker}, una herramienta de reparaci\'on autom\'atica de programas \emph{Java} basada en mutaci\'on para la generaci\'on de candidatos a reparaci\'on, y en SAT Solving para la evaluaci\'on de cada candidato con respecto a las especificaciones del programa. En \ref{sec:repair.striker.evaluation} evaluamos la capacidad de \emph{Stryker} para hacer frente a una gran cantidad de candidatos de reparaci\'on (generados por su uso de \emph{PRVO} entre otros operadores) mediante una novedosa t\'ecnica de poda. Si bien no se provee de un estudio donde se mida cuanto afecta el uso de \emph{PRVO} para encontrar reparaciones que no ser\'ian encontradas sin su inclusi\'on, la evaluaci\'on de Stryker incluy\'o a programas que requirieron de este operador para ser reparados. Una observaci\'on que nos parece importante realizar es que por un lado los defectos se definen mediante una reparaci\'on, por ejemplo, olvidar el incremento de una variable se define mediante la reparaci\'on que agrega a dicho incremento; por otro lado, en \ref{sec:intro.objetivos} y \ref{sec:prvo.prvoTargetedFaults} se mencionan algunos defectos asociados con \emph{PRVO} (aunque es necesario una evaluaci\'on futura para poder confirmar este acoplamiento); estas observaciones en conjunto con la capacidad de Stryker para trabajar con espacios de b\'usqueda grandes, hacen que \emph{PRVO} sea de gran ayuda a la reparaci\'on autom\'atica de programas.