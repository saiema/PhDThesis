\chapter[PRVO]{Operadores de mutaci\'on para expresiones de navegaci\'on}
\label{sec:prvo}

In order to define our mutation operator, we need first to define what we will consider a \emph{chained expression}. Chained expressions will involve a \emph{navigation operator}. In object oriented languages, the navigation operator may take different syntactic forms, with the dot notation being the most commonly found. Its purpose is to access members of a class instance. For simplicity we will refer to a chained expression as one that has zero or more of these operators. The size of a chained expression is given by the number of navigational operators involved. A navigational expression is a chained expression of size 1 or more. 

A direct definition of \emph{prvo} can be given as follows:
\begin{quote}
	Given a chained expression $e$, \emph{prvo} will generate mutations by replacing subexpressions in $e$, respecting the typing of the expression, and maintaining, increasing, or decreasing its size. 
\end{quote}
Figure-\ref{definitions.prvo.simple_def} defines the operator, as a grammar. As a simple example of \emph{prvo} mutations, consider expression \texttt{front}; mutations include \texttt{front.next}, \texttt{null}, \texttt{front.next.next}, \texttt{front.next.elem}, \texttt{front.next.next.next}, and so on. An obvious problem with the above definition is that it is recursive and unbounded, in the sense that there is no limit on how much an expression's size can be expanded or reduced. 

\begin{figure}
	\begin{displaymath}
	\begin{array}{lll}
	PRVO(x)		& :=	& expression \\
	& := & PRVO(x).expression \\
	& := & expression.PRVO(x) \\
	\\
	PRVO(x.y)	& :=	& expression^{*} \\
	& :=	& PRVO(x).expression \\
	& :=	& expression.PRVO(y) \\
	& :=	& PRVO(x).expression.PRVO(y) \\
	& :=	& expression.PRVO(x).PRVO(y) \\
	& :=	& PRVO(x).PRVO(y).expression \\
	\\
	
	\multicolumn{3}{l}{\tiny{^{*} \: : \: can \: include \: x \: or \: y}} \\
	\multicolumn{3}{l}{\tiny{expression \: : \: method \: call \: , \: field \: access \: , variable \: or \: literal}}
	\end{array}
	\end{displaymath}
	\caption{Abstract definition of \emph{prvo}}
	\label{definitions.prvo.simple_def}
\end{figure}

Taking into account the criteria for the design of mutation operators, discussed in Section~2, in particular in regards to the number of mutations that a mutation operator produces, we should provide some reasonable bounds for the application of \emph{prvo}. The number of mutants generated by \emph{prvo} can be limited by limiting three items: the \emph{target} expressions (where will \emph{prvo} be applied); the \emph{expression size}, by how much the size of resulting expressions is allowed to be changed; and the \emph{replacements}, i.e, the expressions to be used for the interleaving/substitutions in \emph{prvo}. Regarding the target, \emph{prvo} will only apply to navigational expressions, i.e., expressions involving at least one navigation. Regarding size, we will limit \emph{prvo} to producing expressions of the \emph{same} size as the original (so the number of navigations is maintained). Regarding replacements, we will only replace expressions with others of exacly the same type (as opposed to considering less strict definitions, that may allow more general compatible types), that belong to the same class where the original expression is found, or classes directly reachable from this class. 

Clearly, this limitations can be thought of as \emph{parameters} of \emph{prvo}, which in some settings may be altered, allowing for richer sets of expressions to consider in replacement, enabling the generation of shorter/longer navigational expressions, etc. In our case, this selection is based on experimentation, taking into account the criteria for mutation operator definitions, mentioned earlier in the paper.